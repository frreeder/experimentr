<div id="graphQuestions">
<div id="graphQTimer"></div>
<p id="graphQInstructions"></p>
<div id="graphQImage"></div>
<div id="graphQVerification"></div><br>
<div id="graphQText"></div>
</div>

<style>
</style>

<script>
(function() {
  // for testing purposes
  var skip = true;
  let mod1 = []
  let graphOrder = []

  var data = {}
    , rand = Math.floor(Math.random()*3) // 0, 1, 2
    , graphCounter = 0
    , lastGraph = false
    , isValid = false
    , graphArray
    , storyData;

  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  }

  function getRandomImageArray(data){
    graphArray = []
    for (var i in data){
      for (let j = 0; j < data[i].length; j++){
        let k = getRandomInt(j, data[i].length)
        let tempI = data[i][j]
        data[i][j]=data[i][k]
        data[i][j].embType=getEmbType(j)
        // data[i][j].
        data[i][j].chartType=i
        data[i][j].index = j
        data[i][k]=tempI
      }
      graphArray=graphArray.concat(data[i])
      // console.log("dataI", data[i])
    }
    for (let i=0; i<graphArray.length; i++){
        let j = getRandomInt(i, graphArray.length)
        let tempI = graphArray[i]
        graphArray[i]=graphArray[j]
        graphArray[j]=tempI
        graphOrder.push({chartType: graphArray[i].chartType, embType: graphArray[i].embType, key: graphArray[i].key, index: graphArray[i].index})
    }
    // freq[arrList.indexOf(3)]++
    console.log("gArray", graphArray, graphOrder)
    console.log("asd", data)
    // return graphArray;
  }

  var embellishType = ["embellished", "normal", "normal2", "unrelated", "unrelated2"]
  function getEmbType(i){
    let embType = ""
    switch (i) {
      case 0:
      case 1:
        embType=embellishType[0];
        break;
      case 2:
        embType=embellishType[1];
        break;
      case 3:
        embType=embellishType[2];
        break;
      case 4:
        embType=embellishType[3];
        break;
      case 5:
        embType=embellishType[4];
        break;
      default:
        console.log("ack!!!");
    }
    return embType
  }

  init();

  function init() {
    // data.mod1=[]
    experimentr.hideNext();
    experimentr.startTimer('graphQuestions');

    d3.json('modules/graphQuestions/data.json', function(err, d) {
      getRandomImageArray(d);
      for (var i=0; i<graphArray.length; i++){
          mod1.push({key: graphArray[i].chartType, inputData: []})
      }
      loadData();
    })
  }

  function loadData() {
    isValid = false
    // Why is this up here? Shoudln't it be in load image? Might be why I'm getting issues...
    // experimentr.attachTimer('#graphQTimer', 5, function() {
    //   loadQuestion();
    // });

    if (graphCounter == graphArray.length-1){
        lastGraph = true;
    }
    storyData = graphArray[graphCounter];
    loadImage();
  }

  function loadImage() {
    experimentr.attachTimer('#graphQTimer', 5, function() {
      loadQuestion();
    });
    d3.select('#graphQInstructions').selectAll("*").remove();
    d3.select("#graphQInstructions").append("strong")
      .text("Please play close attention to the graph.")
    d3.select('#graphQImage').selectAll("*").remove()
    d3.select('#graphQImage').append('img')
      .attr('class', 'picture')
      .style('max-height', "inherit")
      .style("height", "100%")
      // .attr('src', function(d) { return storyData.imagePath[0]; })
      .attr('src', function(d) { return storyData.imagePath[embellishType.indexOf(storyData.embType)]; })
      // .attr('width', "100%");
    // Adds the option for the participant to skip past waiting....might include for testing purposes and remove later. s
    d3.select('#graphQText').selectAll("*").remove()
    if (skip){
      d3.select('#graphQText').append('button')
        .attr('type', 'button')
        .text('I have finished looking at the graph and am ready for the questions.')
        .on('click',
          function(d) {
            loadQuestion();
            // d3.select("#graphQTimer").selectAll("*").remove()
            // d3.select('#graphQTimer').text("")
            experimentr.attachTimerEnd('#graphQTimer')
          });
    }

  }
  function loadQuestion() {
    // two options....one force user to go to next question after x time or place timer below to have user spend x time before proceeding. IF doing that I would probably need to make a new div to have it where the next graph button is.
    // nvm....glitching again
    // experimentr.attachTimer('#graphQTimer', 20, function() {
    // //   d3.select('#graphQVerification').selectAll("*").remove()
    // //   graphCounter++;
    // //   diffGradeMeth();
    // //   if (lastGraph) validate();
    // //   loadData();
    // });
    d3.select('#graphQInstructions').selectAll("*").remove();
    d3.select('#graphQInstructions').append("strong").text(storyData.title+" - "+storyData.embType)
    d3.select('#graphQText').selectAll("*").remove();
    if (!lastGraph){
      d3.select('#graphQText').append('button')
        .attr('type', 'button')
        .text('Next Graph')
        .on('click',
          function(d) {
            if (isValid || skip){
              d3.select('#graphQVerification').selectAll("*").remove()
              graphCounter++;
              loadData();
            }
          });
    } else {
      if (skip){
        diffGradeMeth();
        validate()
      }
      experimentr.showNext();
    }
    
    for (let i=0; i<storyData.questionBank.length; i++){
      mod1[graphCounter].inputData.push({questionType: storyData.questionBank[i].key, userAnswer: ""})
      var question = d3.select('#graphQVerification').append("g")
      question.append('p')
        .text(storyData.questionBank[i].question);
      var choices = question.selectAll('.choice')
        .data(storyData.questionBank[i].choices)
        .enter().append('div')
        .classed('choice', true);
      choices.append('input')
        .attr('type', 'radio')
        .attr('name', 'graphQVerification'+i.toString())
        .attr('value', function(d) { return d; });
      choices.append('label')
        .text(function(d) { return d; });
      d3.selectAll('input')
        .filter(function(d) {
          // console.log("i", i)
          return this.name === 'graphQVerification'+i.toString() ? this : null; })
        .on('change', function() {
          // console.log("i2", i)
          console.log(this.name, this.value, mod1[graphCounter].inputData[i], i)
          mod1[graphCounter].inputData[i].userAnswer = this.value
          // var validate = true;
          if (!isValid){
            // for (var inD in data.mod1[graphCounter].inputData){
            // isValid = true;
            for (let k=0; k<mod1[graphCounter].inputData.length; k++){
              var inD = mod1[graphCounter].inputData[k]
              // console.log("inData", inD, data.mod1[graphCounter].inputData)
              if (inD.userAnswer==""){
                isValid = false
                break;
              } else {
                isValid = true;
              }
            }
          }
          if (isValid || skip){
            // console.log("isValidated!!!")
            diffGradeMeth();
            if (lastGraph) validate();
            // data.graphQVerification = this.value; validate();
          }
        });
    }
  }
  // allow the participant to move on to the next
  function validate() {
    // console.log("validate")
      experimentr.endTimer('graphQuestions');
      data.mod1=JSON.stringify(mod1)
      data.graphOrder=JSON.stringify(graphOrder)
      experimentr.addData(data);
      experimentr.release();
    // }
  }
  function diffGradeMeth(){
    // console.log("sadalkjd", mod1)
    for (var i=0; i<mod1[graphCounter].inputData.length; i++){
      if (mod1[graphCounter].inputData[i].userAnswer==storyData.questionBank[i].answer){
        mod1[graphCounter].inputData[i].answerVerification = true
      } else { mod1[graphCounter].inputData[i].answerVerification = false}
      // console.log(JSON.parse(data.mod1))
      // console.log("apples", JSON.parse("apples"))
    }
  }
}());
</script>
