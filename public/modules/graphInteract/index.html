<div id="graphInteract">
<div id="graphITimer"></div>
<p id="graphIInstructions"></p>
<div id="graphIImage" class="graphIImage"></div>
<div id="interactButtons"></div>
<div id="graphIVerification"></div><br>
<div id="graphIText"></div>
</div>

<style>
</style>

<script>
(function() {
  // for testing purposes
  var skip = true;
  var stepSize = .005
  let mod4 = []

  // Specific to interact
  var chart;
  // let perc = [.8, 1]
  // var bodyDim = {h:parseInt(d3.select('#graphIImage').style('height'), 10)*perc[0] , w:parseInt(d3.select('#graphIImage').style('width'), 10)*perc[1]}
  let perc = [1, .8]
  // Might need to change this to hard coded numbers, but keeping for now.
  var bodyDim = {w:parseInt(d3.select('#graphIImage').style('width'), 10)*perc[0], h:parseInt(d3.select('#graphIImage').style('height'), 10)*perc[1]}
  bodyDim.h = 500*perc[1]
  console.log("bod", bodyDim)

  var data = {}
    , rand = Math.floor(Math.random()*3) // 0, 1, 2
    , graphCounter = 0
    , lastGraph = false
    , isValid = false
    , graphArray
    , storyData;

  function clampThings(num, min, max){return Math.min(Math.max(num, min), max)}

  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  }

  function getRandomImageArray(data){
    graphArray = []
    for (var i in data){
      for (let j = 0; j < data[i].length; j++){
        let k = getRandomInt(j, data[i].length)
        let tempI = data[i][j]
        data[i][j]=data[i][k]
        data[i][j].embType=getEmbType(j)
        // data[i][j].
        data[i][j].chartType=i
        data[i][k]=tempI
      }
      graphArray=graphArray.concat(data[i])
      // console.log("dataI", data[i])
    }
    for (let i=0; i<graphArray.length; i++){
        let j = getRandomInt(i, graphArray.length)
        let tempI = graphArray[i]
        graphArray[i]=graphArray[j]
        graphArray[j]=tempI
    }
  }

  var embellishType = ["embellished", "normal", "normal2", "unrelated", "unrelated2"]
  function getEmbType(i){
    let embType = ""
    switch (i) {
      case 0:
      case 1:
        embType=embellishType[0];
        break;
      case 2:
        embType=embellishType[1];
        break;
      case 3:
        embType=embellishType[2];
        break;
      case 4:
        embType=embellishType[3];
        break;
      case 5:
        embType=embellishType[4];
        break;
      default:
        console.log("ack!!!");
    }
    return embType
  }

  init();

  function init() {
    // data.mod1=[]
    experimentr.hideNext();
    experimentr.startTimer('');

    d3.json('modules/graphQuestions/data.json', function(err, d) {
      getRandomImageArray(d);
      for (var i=0; i<graphArray.length; i++){
          mod4.push({key: graphArray[i].chartType, inputData: []})
      }
      // Getting the line interact data
      for (let i = 0; i < graphArray.length; i++){
        if (graphArray[i].chartType!="line" && graphArray[i].chartType!="pie") continue;
        d3.csv(graphArray[i].interact.dataPath, function(iData){
          // Setting the accessors based on the column and row data
          graphArray[i].interact.accessors = [d3.keys(iData[0])[0], d3.keys(iData[0])[1]]
          // Turning the strings into floats for the values
          iData.map((d)=>{
    				d[graphArray[i].interact.accessors[1]]= parseFloat(d[graphArray[i].interact.accessors[1]])
    			})
          // Adding data to the main graph array
          graphArray[i].interact.data = iData
        })
      }
      console.log("iData", graphArray)
      // This is here to ensure the data gets loaded....
      // Need to add text to let the participants know what they are looking at
      d3.select('#graphIText').selectAll("*").remove()
      d3.select('#graphIText').append('text').text("Use the up and down arrow buttons to change the value of the graph to match your memory of the graphs").append("br")
      d3.select('#graphIText').append('button')
        .attr('type', 'button')
        .text('I have finished looking at the graph and am ready for the questions.')
        .on('click',
          function(d) {
            loadData();
          });
    })
  }

  function loadData() {
    isValid = false

    if (graphCounter == graphArray.length-1){
        lastGraph = true;
    }
    storyData = graphArray[graphCounter];
    loadImage();
  }

  function loadImage() {
    d3.select('#graphIInstructions').selectAll("*").remove();
    d3.select("#graphIInstructions").append("strong")
      .text("Please use arrow keys to adjust the graph to memory.")
    d3.select('#interactButtons').selectAll("*").remove();
    // $('#interactButtons').html("<br><text>Use buttons to visually adjust the value of the chart.<text><br>")
    d3.select('#interactButtons').html("<br><text>Use buttons to visually adjust the value of the chart.<text><br>")
    // d3.select('#interactButtons').append('text').text('Use buttons to visually adjust the value of the chart.')
    // d3.select('#interactButtons').append('br')
    d3.select('#graphIImage').selectAll("*").remove()
    // If not line for now

    switch (storyData.chartType) {
      case "line":
        makeLine();
        break;
      case "pie":
        makePie();
        break;
      case "bar":
        makeBar();
        break;
      default:
        makePower();
        break;
    }
    loadQuestion();
  }

  function makePower() {
    d3.select('#graphIImage').append('img')
      .attr('class', 'picture')
      .attr('src', function(d) { return "modules/graphQuestions/graphImages/color/rangerPoseGreen.png"; })
      // Doesn't keep the aspect ratio...but I'm okay with that...for now.
      .style('height', perc[1]*100+"%")
      .style('width', perc[0]*100+"%")
  }

  function makeBar(){
    // temp
    imgDim = storyData.interact.imageDim
    imgRat = imgDim[0]/imgDim[1]

    chart = d3.select('#graphIImage').append("svg").attr("class", "bar")

    chart.bodyDim = {w: bodyDim.w, h: bodyDim.h}
    chart.bodyDim.w = chart.bodyDim.w > chart.bodyDim.h ? chart.bodyDim.h*imgRat : chart.bodyDim.w;
    chart.bodyDim.h = chart.bodyDim.w > chart.bodyDim.h ? chart.bodyDim.h : chart.bodyDim.w/imgRat;
    console.log("img", chart.bodyDim, imgRat)
    // Append the SVG setting the viewbox based on bodyDim and scaling based on window
    chart
      .attr("viewBox", "0 0 "+(chart.bodyDim.w).toString()+" "+(chart.bodyDim.h).toString())
      .attr("preserveAspectRatio", "xMinYMax meet")
      // .attr("viewBox", "0 0 "+(bodyDim.w*perc[0]).toString()+" "+(bodyDim.h*perc[1]).toString())
      // .style('height', bodyDim.h*perc[1])
      // .style('width', bodyDim.w*perc[0])
      // .style('height', perc[1]*100+"%")
      // .style('width', perc[0]*100+"%")
      .attr('height', perc[1]*100+"%")
      .attr('width', perc[0]*100+"%")

    // Append the background image for all the bars except the one being modified.
    chart.append('image')
      .attr('class', 'picture')
      // .attr('href', function(d) { return storyData.interact.imagePath[0]; })
      .attr('href', function(d) { return "modules/graphQuestions/graphImages/interact/bar_interact_01_developers.png"; })
      .attr('height', chart.bodyDim.h)
      .attr('width', chart.bodyDim.w)
      // .attr('height', bodyDim.h*perc[1])
      // .attr('width', bodyDim.w*perc[0])
      // .style('height',"100%")
      // .style('width', "100%")

    // Append the buttons for controlling the width of the bars.
    for (let i =0; i<2; i++){
      let buttonType = i==0? "up" : "down"
      let isInc = i==0
      d3.select('#interactButtons').append("button")
        // .style("height", (100*(1-perc[1])).toString()+"%")
        .attr("class", "button1 "+buttonType)
        .on("click", ()=>{
          incBar(isInc, .01)
        })
        .on("mousedown", ()=>{
          clearTimeout(chart.timer)
          chart.outline.style("opacity", 1)
          chart.timer = setTimeout(()=>{chart.outline.style("opacity", .2)}, 500)
        })
        // .on("mouseup", ()=>{chart.outline.style("opacity", .2)})
        // .append("img")
        //   .attr("src", "modules/graphInteract/buttons/"+buttonType+".png")
        //   .attr("class", "button1")
        //   .style("height", "100%")
    }

    // Reminding you that bar width needs to be between 0 and 1.
    chart.barWidth = clampThings(1, 0, 1)

    // Adding a clipping path to clip the image with the bar that we want to manipulate.
    chart.bar = chart
      .append("defs")
      .append("clipPath")
      .attr("id", "clipper1")
      .append("rect")
      .attr('height',chart.bodyDim.h)
      .attr('width', (chart.barWidth)*chart.bodyDim.w)

    // This would be the outline
    chart.outline=chart.append('image')
      .attr('class', 'picture clip-svg1')
      // .attr('href', function(d) { return storyData.interact.imagePath[1]; })
      .attr('href', function(d) { return "modules/graphQuestions/graphImages/interact/bar_interact_03_developers.png"; })
      .attr('height', chart.bodyDim.h)
      .attr('width', (chart.barWidth)*chart.bodyDim.w)
      .style("opacity", .2)

    // Adding the image of the bar that we want to manipulate. The file must be the bar in the same space as background bar image.
    chart.append('image')
      .attr('class', 'picture clip-svg1')
      // .attr('href', function(d) { return storyData.interact.imagePath[1]; })
      .attr('href', function(d) { return "modules/graphQuestions/graphImages/interact/bar_interact_02_developers.png"; })
      .attr('height', chart.bodyDim.h)
      .attr('width', (chart.barWidth)*chart.bodyDim.w)
  }

  function incBar(isInc, step){
    // Making sure the bar does not exceed the 0 and 1.
    chart.barWidth= clampThings((isInc? chart.barWidth+step : chart.barWidth-step), 0, 1)
    // Updating the clipping path.
    chart.bar.attr('width', (chart.barWidth)*chart.bodyDim.w*perc[0])
  }

  function makePie() {
    let pieData = storyData.interact.data
    let accessors = storyData.interact.accessors
    let piePerc = .9

    // Setting the chart
    chart = d3.select('#graphIImage')
    // Setting the width to almost 70 to give room for legend...though legend might not be necessary in future iterations...
    chart.bodyDim = {w:bodyDim.w*.65, h: bodyDim.h}
    console.log("pieTime", storyData, chart.bodyDim)
    // I'm thinking of placing this up in the switch statement area and having the function be a variable based on switch.
    // Redudant for now
    // Or add a variable to inc function and do something based on that...
    for (let i =0; i<2; i++){
      let buttonType = i==0? "up" : "down"
      let isInc = i==0
      d3.select('#interactButtons').append("button")
        // .style("height", (100*(1-perc[1])).toString()+"%")
        .attr("class", "button1 "+buttonType)
        .on("click", ()=>{
          incSlice(isInc, 1)
          clearTimeout(chart.timer)
          chart.highSlice.style("opacity", 1)
          chart.timer = setTimeout(()=>{chart.highSlice.style("opacity", .4)}, 500)
        })
    }
    // Setting a color scale if not predefined.
    chart.colorScale = d3.scale.category10()
      // .attr("height", chart.bodyDim.h)

    // Getting the minimum chart Dimensions and setting it as the diameter of the circle.
    let dia  = Math.min(chart.bodyDim.w, chart.bodyDim.h)

    // Create the SVG
    chart.plotArea = chart.append("svg").attr("class", "pie")
      .attr('width', perc[0]*100*piePerc+"%")
      .attr('height', perc[1]*100+"%")
      .attr("viewBox", ((chart.bodyDim.w-dia)/2).toString()+" "+((chart.bodyDim.h-dia)/2).toString()+" "+(dia).toString()+" "+(dia).toString())
      .attr("preserveAspectRatio", "xMinYMax meet")
      // .attr("viewBox", "0 0 "+(bodyDim.w).toString()+" "+(bodyDim.h).toString())

    // Appending a group for random SVG elements and dimensions
    chart.pieArea = chart.plotArea.append("g")

    chart.pieArea.r = dia / 2

    chart.pieArea.raySize = chart.pieArea.r*.7
    let raySize = chart.pieArea.raySize
    chart.legendArea = chart.append("table").attr('class','legend pie')
      .attr('width', perc[0]*100*(1-piePerc)+"%")
      // .style("margin-top", (chart.pieArea.r).toString()+"px").append("tbody")

    // The arc function to specify the paths for the pie.
    var arc = d3.svg.arc().outerRadius(chart.pieArea.r - 10).innerRadius(0);
    // A function to specify the angles of the pie.
    var pie = d3.layout.pie(pieData).sort(null).value(function(d) { return d[accessors[1]]; });

    // Add pie make here
    if (storyData.interact.withIcon){
      // Creating pie slices
      var pieInfo = pie(pieData)
      // The clipping paths for the icons.
      chart.pieArea
        .selectAll("path")
        .data(pie(pieData)).enter()
        .append("defs").append("clipPath")
        .attr("id", function(d,i){
          return "clipper"+(i+1).toString()
          })
        .append("path")
        .attr("transform", "translate("+chart.bodyDim.w/2+","+chart.bodyDim.h/2+")")
          .attr("d", arc)
          .style("fill", function(d, i) { return chart.colorScale(i); })
          .each(function(d) { this._current = d; })
      // console.log("pie", pieInfo)

      // The base color
      chart.plotArea.append("g")
        .attr("class", "outline")
        .selectAll("path")
        // .remove().exit()
        .data(pie(pieData)).enter()
        .append("path")
        .attr("transform", "translate("+chart.bodyDim.w/2+","+chart.bodyDim.h/2+")")
          .attr("d", arc)
          .style("fill", (d,i)=>{return storyData.interact.colorArray[i]})
          .style("stroke", "none")
          // .style("stroke-width", 3)
          .each(function(d) { this._current = d; })

      // Creating icons
      // console.log("bodyDim", chart.bodyDim, chart.pieArea.r)
      imgCon = {max: chart.pieArea.r*.6, min: 50}
      chart.pieArea.imgCon = imgCon
      chart.pieArea.icons=chart.plotArea.append("g")
        .attr("class", "icons")
        .selectAll("image")
        .data(storyData.interact.imagePath)
        .enter().append("image")
          .attr("align", "center")
          .attr("href", (d)=>{return d.path})
          .attr("class", (d,i)=>{return "clip-svg"+(i+1).toString()})
          // .style("width", 100)
          // .style("height", 100)
          .attr("width", (d,i)=>{
            var xChange = Math.pow(Math.cos(pieInfo[i].endAngle)-Math.cos(pieInfo[i].startAngle),2)
            var yChange = Math.pow(Math.sin(pieInfo[i].endAngle)-Math.sin(pieInfo[i].startAngle),2)
            // console.log("x", xChange, yChange)
            d.width = clampThings(Math.sqrt(xChange+yChange)*raySize, imgCon.min, imgCon.max)
            // d.width = Math.min(Math.max(Math.sqrt(xChange+yChange)*raySize, imgCon.min), imgCon.max)
            // console.log("s", d.width, imgCon, Math.sqrt(xChange+yChange)*raySize, clampThings(Math.sqrt(xChange+yChange)*raySize, imgCon.min, imgCon.max))
            return d.width
          })
          .attr("height", (d, i)=>{return d.width})
          .attr("x", (d, i)=>{
            return Math.cos((pieInfo[i].endAngle-pieInfo[i].startAngle)/2+pieInfo[i].startAngle-1.57)*raySize+chart.bodyDim.w/2-d.width/2
              // console.log("d", d, pieInfo[i])
          })
          .attr("y", (d, i)=>{return Math.sin((pieInfo[i].endAngle-pieInfo[i].startAngle)/2+pieInfo[i].startAngle-1.57)*raySize+(chart.bodyDim.h/2-d.width/2)})
    } else {
      chart.pieArea
        .append("circle")
        .attr("r", chart.pieArea.r)
        .attr("cx", chart.bodyDim.w/2)
        .attr("cy", chart.bodyDim.h/2)
        .attr("fill", "red")
        .style("opacity", .2)

      // Draw the pie slices.
      // Removed the transition because it was showing black artifact ... probably from the fille...
      chart.pieArea
        .selectAll("path")
        // .remove().exit()
        .data(pie(pieData)).enter()
        .append("defs").append("clipPath")
        .attr("id", function(d,i){
          return "clipper"+(i+1).toString()
          })
        .append("path")
        // I need to put transform here to have the group in the same coordinates as the clipping path.
        .attr("transform", "translate("+chart.bodyDim.w/2+","+chart.bodyDim.h/2+")")
        // .transition().delay(100)
          .attr("d", arc)
          .style("fill", function(d, i) { return chart.colorScale(i); })
          .each(function(d) { this._current = d; })

      var imgD = chart.pieArea.r*2

      var fileNames = ["potatoes", "pita", "fries", "rice", "tortillaBrown"]
      for (let i = 0; i < storyData.interact.imagePath.length; i++){
        if (i>pieData.length-1){continue;}
        chart.plotArea.append("g")
          .attr("class", "clip-svg"+(i+1).toString())
          // .append("image").attr("href", "/data/land.png").style("width", "auto").style("height", "100%")
          .append("image").attr("href", storyData.interact.imagePath[i].path)
          .attr("width", imgD).attr("height", imgD)
          .attr("x", chart.bodyDim.w/2-storyData.interact.imageDim[1]/storyData.interact.imageDim[0]*chart.pieArea.r)
          .attr("y", chart.bodyDim.h/2-storyData.interact.imageDim[0]/storyData.interact.imageDim[1]*chart.pieArea.r)
          .style("position", "absolute")
      }
    }
    // this is responsible for the outline of the pie slices
    chart.plotArea.append("g")
      .attr("class", "outline")
      .selectAll("path")
      // .remove().exit()
      .data(pie(pieData)).enter()
      .append("path")
      // I need to put transform here to have the group in the same coordinates as the clipping path.
      .attr("transform", "translate("+chart.bodyDim.w/2+","+chart.bodyDim.h/2+")")
      // .transition().delay(100)
        .attr("d", arc)
        .style("fill", "none")
        .style("stroke", "black")
        .style("stroke-width", 3)
        .each(function(d) { this._current = d; })
    chart.highSlice = chart.plotArea.append("g")
      .attr("class", "highlight")
      .append("path").datum(pie(pieData)[1])
      .attr("transform", "translate("+chart.bodyDim.w/2+","+chart.bodyDim.h/2+")")
        .attr("d", arc)
        .style("fill", "none")
        .style("stroke", "#FF1493")
        .style("stroke-width", 3)
        .style("opacity", .4)

  }

  function incSlice (isInc, inc){
    let pieData = storyData.interact.data
    let accessors = storyData.interact.accessors
    // pieData[0]
    // here I need to increase or decrease the value of a slice and adjust the surrounding accordingly.
    // if (pieData[0][accessors[1]]>=inc&&pieData[1][accessors[1]]>=inc){
      if (isInc && pieData[0][accessors[1]]>inc/2 && pieData[2][accessors[1]]>inc/2){
        pieData[1][accessors[1]]+=inc
        pieData[0][accessors[1]]-=inc/2
        // pieData[pieData.length-1][accessors[1]]-=inc/2
        pieData[2][accessors[1]]-=inc/2
      } else if (!isInc && pieData[1][accessors[1]]>inc) {
        console.log(pieData[0][accessors[1]], pieData[1][accessors[1]])
        pieData[1][accessors[1]]-=inc
        pieData[0][accessors[1]]+=inc/2
        // pieData[pieData.length-1][accessors[1]]+=inc/2
        pieData[2][accessors[1]]+=inc/2
      } else {
        return; }
    // }

    // console.log("slices", pieData[0][accessors[1]], pieData[1][accessors[1]])

    // create function to draw the arcs of the pie slices.
    var arc = d3.svg.arc().outerRadius(chart.pieArea.r - 10).innerRadius(0);

    // create a function to compute the pie slice angles.
    var pie = d3.layout.pie(pieData).sort(null).value(function(d) { return d[accessors[1]]; });
    var pieInfo = pie(pieData)
    console.log("newPi", pieInfo)

    chart.pieArea.selectAll("path")
      .data(pie(pieData))
      .attr("d", arc)

    chart.highSlice
      .datum(pie(pieData)[1])
      .attr("d", arc)

    chart.plotArea.selectAll(".outline").selectAll("path")
      .data(pie(pieData))
      .attr("d", arc)

    // If icons
    // console.log("char", chart.plotArea.select(".icons").selectAll("image"), chart.plotArea.select(".outline").selectAll("path"))
    chart.plotArea.select(".icons")
      .selectAll("image")
    // chart.pieArea.icons
      // .data(storyData.interact.imagePath)
      // .each(()=>{console.log("doing stuff")})
      .attr("width", (d, i)=>{
        if (i<3){
          var xChange = Math.pow(Math.cos(pieInfo[i].endAngle)-Math.cos(pieInfo[i].startAngle),2)
          var yChange = Math.pow(Math.sin(pieInfo[i].endAngle)-Math.sin(pieInfo[i].startAngle),2)
          d.width = clampThings(Math.sqrt(xChange+yChange)*chart.pieArea.raySize, chart.pieArea.imgCon.min, chart.pieArea.imgCon.max)
        }
        // console.log("d.w", d.width)
        return d.width
      })
      .attr("height", (d)=>{return d.width})
      .attr("x", (d, i)=>{
        // console.log("ray", chart.pieArea.raySize, Math.cos((pieInfo[i].endAngle-pieInfo[i].startAngle)/2+pieInfo[i].startAngle-1.57)*chart.pieArea.raySize, d.width)
        return Math.cos((pieInfo[i].endAngle-pieInfo[i].startAngle)/2+pieInfo[i].startAngle-1.57)*chart.pieArea.raySize+chart.bodyDim.w/2-d.width/2
      })
      .attr("y", (d, i)=>{return Math.sin((pieInfo[i].endAngle-pieInfo[i].startAngle)/2+pieInfo[i].startAngle-1.57)*chart.pieArea.raySize+(chart.bodyDim.h/2-d.width/2)})

  }

  function makeLine() {
    // console.log("here", storyData.interact, storyData.interact.imageDim[0])
    let labelArray = storyData.interact.data.map((d)=>{return d[storyData.interact.accessors[0]]})
    let accessors = storyData.interact.accessors
    let lineData = storyData.interact.data
    let pointLoc = typeof(storyData.interact.pointLoc)==='number'? clampThings(storyData.interact.pointLoc, 1, lineData.length-1) : (2<lineData.length-1? 2 : 1)
    storyData.interact.pointLoc = pointLoc

    chart = d3.select('#graphIImage').append("svg").attr("class", "lineGraph")
      .attr("preserveAspectRatio", "xMinYMax meet")

    chart.bodyDim = {w: bodyDim.w, h: bodyDim.h}
    chart.bodyDim.w = chart.bodyDim.w > chart.bodyDim.h ? chart.bodyDim.h*(storyData.interact.imageDim[0][0]/storyData.interact.imageDim[0][1]) : chart.bodyDim.w;
    chart.bodyDim.h = chart.bodyDim.w > chart.bodyDim.h ? chart.bodyDim.h : chart.bodyDim.w/(storyData.interact.imageDim[0][0]/storyData.interact.imageDim[0][1]);

    // console.log("ptLoc", pointLoc)
    // Adding the chart svg
    chart
      .attr("height", perc[1]*100+"%").attr("width", perc[0]*100+"%")
      .attr("viewBox", "0 0 "+chart.bodyDim.w.toString()+" "+chart.bodyDim.h.toString())
    // Setting the margin
    chart.margin = {top: chart.bodyDim.h*.05, right: chart.bodyDim.w*.1, bottom: chart.bodyDim.h*.05, left: chart.bodyDim.w*.1}
    // Adding buttons for changing the values
    for (let i =0; i<2; i++){
      let buttonType = i==0? "up" : "down"
      let isInc = i==0
      d3.select('#interactButtons').append("button")
        // .style("height", "20%")
        .attr("class", "button1 "+buttonType)
        .on("click", ()=>{
          incPoint(isInc)
          clearTimeout(chart.timer);
          chart.highLine.style("opacity", "1")
          chart.timer = setTimeout(()=>{chart.highLine.style("opacity", ".5")}, 500)
        })
        // .append("img")
        //   .attr("src", "modules/graphInteract/buttons/"+buttonType+".png")
        //   .style("height", "100%")
    }
    // Setting the plot area
    chart.plotArea = chart.append("g")

    // Setting the height and width of the chart based on the ratio of the image.
    chart.plotArea.height = chart.bodyDim.h - chart.margin.top - chart.margin.bottom;
    chart.plotArea.width = chart.bodyDim.w - chart.margin.left - chart.margin.right
    // Need to redo this step because allocating room for the margin messes up the ratio of the chart body
    chart.plotArea.width = chart.plotArea.height>chart.plotArea.width? chart.plotArea.width : chart.plotArea.height * storyData.interact.imageDim[0][0]/storyData.interact.imageDim[0][1]
    chart.plotArea.height = chart.plotArea.height>chart.plotArea.width? chart.plotArea.width * storyData.interact.imageDim[0][1]/storyData.interact.imageDim[0][0] : chart.plotArea.height

    // console.log("ww", chart.plotArea.width, chart.plotArea.height, chart.bodyDim.w, chart.bodyDim.h)
    // console.log("ch", chart.plotArea.height, chart.plotArea.width, chart.margin)

    // Setting the scales for the x and y coordinate system
    // chart.xScale = d3.scale.ordinal().domain(labelArray).range(d3.range(0, chart.plotArea.width, chart.plotArea.width/(labelArray.length)));
    chart.xScale = d3.scale.ordinal().domain(labelArray).range(d3.range(labelArray.length).map((d)=>{ return d / labelArray.length * chart.plotArea.width; }));
    // console.log("sc", chart.xScale.domain(), chart.xScale.range(), d3.range(labelArray.length).map((d)=>{ return d / labelArray.length * chart.plotArea.width; }))
    chart.yScale = d3.scale.linear().range([chart.plotArea.height, 0])
      .domain([0, 1.1*d3.max(storyData.interact.data, function(d) { return d[storyData.interact.accessors[1]]; })])
      .clamp(true)
    storyData.interact.stepSize = chart.yScale.domain()[1]*stepSize

    // define the line function
    chart.lineFunc = d3.svg.line()
      .x(function(d) { return chart.xScale(d[storyData.interact.accessors[0]]); })
      .y(function(d) { return chart.yScale(d[storyData.interact.accessors[1]]); });

    // Setting the calculated width and height to the chart plot area and moving accordingly
    chart.plotArea
        .attr("width", chart.plotArea.width)
        .attr("height", chart.plotArea.height)
        .attr("transform",
              "translate(" + chart.margin.left + "," + chart.margin.top + ")");

    // If there is an icon, setting it to a percent of the chart plot area
    // Needs to be fixed...
    storyData.interact.iconDim = chart.plotArea.width/13

    // This is the background image / the top
    chart.plotArea.append("image")
        .attr("class", "clip-svg2")
        .attr("width", chart.plotArea.width)
        .attr("height", chart.plotArea.height)
        .attr("href", storyData.interact.imagePath[1])

    // This is the foreground image / the bottom
    chart.plotArea.append("image")
      .attr("class", "clip-svg1")
      .attr("width", chart.plotArea.width)
      .attr("height", chart.plotArea.height)
      .attr("href", storyData.interact.imagePath[0])

    // This is the line outline
    chart.plotArea.append("path")
      .datum(storyData.interact.data)
      .attr("class", "lineOutline")
      .attr("d", chart.lineFunc)
      // .style("stroke", (d, i)=>{if (i==pointLoc || i == pointLoc-1){return "pink"} else {return "black"}})
      // .style("stroke-width", (d, i)=>{if (i==pointLoc || i == pointLoc-1){return "pink"} else {return "black"}})
      // .attr("d", d3.svg.line()
		  //   .x(function(d) { return chart.xScale(d[storyData.interact.accessors[0]]); })
		  //   .y(function(d) { return chart.yScale(d[storyData.interact.accessors[1]]); })
			// );
    // Get segment of the lines.
    // manipLineData = [{source: storyData.interact.data[pointLoc-1], target:storyData.interact.data[pointLoc]},
    //   {source: storyData.interact.data[pointLoc], target:storyData.interact.data[pointLoc+1>storyData.interact.data.length-1?pointLoc:pointLoc+1]}]
    // for (let i = pointLoc-1; i < pointLoc+2; i++){
    //   if ()
    //   manipLineData
    // }
    chart.manipLines = storyData.interact.data.slice(pointLoc-1, pointLoc+2)
    // chart.highLine = chart.plotArea.append("g").selectAll("line")
    //   .data(manipLineData)
    //   .enter().append("line")
    //     .attr("x1", (d)=>{return chart.xScale(d.source[accessors[0]])})
    //     .attr("x2", (d)=>{return chart.xScale(d.target[accessors[0]])})
    //     .attr("y1", (d)=>{return chart.yScale(d.source[accessors[1]])})
    //     .attr("y2", (d)=>{return chart.yScale(d.target[accessors[1]])})
    //     .style("stroke", "#FF1493")
    //     .style("stroke-width", 3)
    //     .style("opacity", .5)

    chart.highLine = chart.plotArea.append("g").append("path")
      .datum(chart.manipLines)
      .attr("d", chart.lineFunc)
      .style("stroke", "#FF1493")
      .style("stroke-width", 3)
      .style("fill", "none")
      .style("opacity", .5)


    // this is the icon attached to the line chart if used... a bit buggy but I suspect it has something to do with the rotation point.
    if (storyData.interact.withIcon){
      let m = -(chart.yScale(lineData[pointLoc][accessors[1]])-chart.yScale(lineData[pointLoc-1][accessors[1]]))/(chart.xScale(lineData[pointLoc][accessors[0]])-chart.xScale(lineData[pointLoc-1][accessors[0]]))
      let xPos = (chart.xScale(lineData[pointLoc][accessors[0]])-chart.xScale(lineData[pointLoc-1][accessors[0]]))/2+chart.xScale(lineData[pointLoc-1][accessors[0]])
      let yPos = (chart.yScale(lineData[pointLoc][accessors[1]])-chart.yScale(lineData[pointLoc-1][accessors[1]]))/2+chart.yScale(lineData[pointLoc-1][accessors[1]])-storyData.interact.iconDim
      chart.plotArea.append("image")
          .attr("class", "icon")
          .attr("width", storyData.interact.iconDim)
          .attr("position", "center")
          .attr("href", storyData.interact.imagePath[2])
          .attr("transform", "rotate("+(-Math.atan(m)*180/Math.PI)+","+(xPos)+","+(yPos)+")")
          .attr("x", xPos)
          .attr("y", yPos)
    }

    for (let i = 0; i <2; i++){
      let y0 = i==0? chart.yScale(0) : chart.yScale.range()[1]
      var area = d3.svg.area()
        .x(function(d, i) { return chart.xScale(d[accessors[0]]); })
        .y0(function(d) { return y0; })
        .y1(function(d) { return chart.yScale(d[accessors[1]]); });
      chart.plotArea
        .append("defs").append("clipPath")
        .attr("class", "c"+(i+1).toString())
        .attr("id", "clipper"+(i+1).toString())
        .append("path")
        .datum(lineData)
        .attr("class", "stackLine")
        .attr("d", area)
    }

    // Add the X Axis
	  chart.xAxis = chart.plotArea.append("g").attr("class", "xScale")
	      .attr("transform", "translate(0," + chart.plotArea.height + ")")
	      .call(d3.svg.axis().scale(chart.xScale).orient("bottom"));

	  // Add the Y Axis
	  chart.yAxis = chart.plotArea.append("g").attr("class", "yScale")
	      .call(d3.svg.axis().scale(chart.yScale).orient("left"));

  }

  function loadQuestion() {
    d3.select('#graphIInstructions').selectAll("*").remove();
    d3.select('#graphIInstructions').append("strong").text(storyData.title+" - "+storyData.embType)
    d3.select('#graphIText').selectAll("*").remove();
    if (!lastGraph){
      d3.select('#graphIText').append('button')
        .attr('type', 'button')
        .text('Next Graph')
        .on('click',
          function(d) {
            if (isValid || skip){
              d3.select('#graphIVerification').selectAll("*").remove()
              graphCounter++;
              loadData();
            }
          });
    } else {
      if (skip){
        diffGradeMeth();
        validate()
      }
      experimentr.showNext();
    }
    // only looking at one thing for now
    for (let i=0; i<storyData.questionBank.length; i++){
      mod4[graphCounter].inputData.push({questionType: storyData.questionBank[i].key})
      var question = d3.select('#graphIVerification').append("g")
      question.append('p')
        .text(storyData.questionBank[i].question);
      var choices = question.selectAll('.choice')
        .data(storyData.questionBank[i].choices)
        .enter().append('div')
        .classed('choice', true);
      choices.append('input')
        .attr('type', 'radio')
        .attr('name', 'graphIVerification'+i.toString())
        .attr('value', function(d) { return d; });
      choices.append('label')
        .text(function(d) { return d; });
      d3.selectAll('input')
        .filter(function(d) {
          // console.log("i", i)
          return this.name === 'graphIVerification'+i.toString() ? this : null; })
        .on('change', function() {
          // console.log("i2", i)
          console.log(this.name, this.value, mod4[graphCounter].inputData[i], i)
          mod4[graphCounter].inputData[i].userAnswer = this.value
          // var validate = true;
          if (!isValid){
            // for (var inD in data.mod1[graphCounter].inputData){
            // isValid = true;
            for (let k=0; k<mod4[graphCounter].inputData.length; k++){
              var inD = mod4[graphCounter].inputData[k]
              // console.log("inData", inD, data.mod1[graphCounter].inputData)
              if (inD.userAnswer==null){
                isValid = false
                break;
              } else {
                isValid = true;
              }
            }
          }
          if (isValid || skip){
            // console.log("isValidated!!!")
            diffGradeMeth();
            if (lastGraph) validate();
            // data.graphIVerification = this.value; validate();
          }
        });
    }
  }

  function incPoint (isInc){
    let lineData = storyData.interact.data
    let accessors = storyData.interact.accessors
    let inc = storyData.interact.stepSize
    let pointLoc = storyData.interact.pointLoc
    if (isInc){
      lineData[pointLoc][accessors[1]]+=inc
    } else {lineData[pointLoc][accessors[1]]-=inc}

    for (let i = 0; i <2; i++){
      let y0 = i==0? chart.yScale(0) : chart.yScale.range()[1]
      var area = d3.svg.area()
        .x(function(d, i) { return chart.xScale(d[accessors[0]]); })
        .y0(function(d) { return y0; })
        .y1(function(d) { return chart.yScale(d[accessors[1]]); });
      chart.plotArea.selectAll(".c"+(i+1).toString()).select("path")
        .datum(lineData)
        .attr("d", area)
    }

    chart.highLine
      // .datum(chart.manipLines)
      .attr("d", chart.lineFunc)
        // .attr("x1", (d)=>{return chart.xScale(d.source[accessors[0]])})
        // .attr("x2", (d)=>{return chart.xScale(d.target[accessors[0]])})
        // .attr("y1", (d)=>{return chart.yScale(d.source[accessors[1]])})
        // .attr("y2", (d)=>{return chart.yScale(d.target[accessors[1]])})

    chart.plotArea.selectAll(".lineOutline")
      .datum(lineData)
      .attr("d", chart.lineFunc);

    if (storyData.interact.withIcon){
      let m = -(chart.yScale(lineData[pointLoc][accessors[1]])-chart.yScale(lineData[pointLoc-1][accessors[1]]))/(chart.xScale(lineData[pointLoc][accessors[0]])-chart.xScale(lineData[pointLoc-1][accessors[0]]))
      let xPos = (chart.xScale(lineData[pointLoc][accessors[0]])-chart.xScale(lineData[pointLoc-1][accessors[0]]))/2+chart.xScale(lineData[pointLoc-1][accessors[0]])
      let yPos = (chart.yScale(lineData[pointLoc][accessors[1]])-chart.yScale(lineData[pointLoc-1][accessors[1]]))/2+chart.yScale(lineData[pointLoc-1][accessors[1]])-storyData.interact.iconDim
      chart.plotArea.selectAll(".icon")
          .attr("transform", "rotate("+(-Math.atan(m)*180/Math.PI)+","+(xPos)+","+(yPos)+")")
          .attr("y", yPos)
    }
  }

  // allow the participant to move on to the next
  function validate() {
    // console.log("validate")
      experimentr.endTimer('graphInteract');
      data.mod4=JSON.stringify(mod4)
      console.log(JSON.parse(data.mod4))
      experimentr.addData(data);
      experimentr.release();
    // }
  }
  // need to edit this
  function diffGradeMeth(){
    for (var i=0; i<mod4[graphCounter].inputData.length; i++){
      if (mod4[graphCounter].inputData[i].userAnswer==storyData.questionBank[i].answer){
        mod4[graphCounter].inputData[i].answerVerification = true
      } else { mod4[graphCounter].inputData[i].answerVerification = false}
      // console.log("apples", JSON.parse("apples"))
    }
  }
}());
</script>
