<div id="graphInteract">
<div id="graphITimer"></div>
<p id="graphIInstructions"></p>
<div id="graphIImage" class="graphIImage"></div>
<div id="interactButtons"></div>
<div id="graphIVerification"></div><br>
<div id="graphIText"></div>

<style>
</style>

<script>
(function() {
  var skip = false; // Whether or not can click proceed without completing the module
  let mod4 = [] // The data being saved for the module
  let tutTime = true; // If a tutorial is being done

  var stepSize = .005 // The steps for increasing/decreasing selected data values
  let changeAllSlices = true; // true: manipulate all pie slices, false: manipulate selected slice and adjacent ones

  // What charts are being shown
  let isBW = true; // true: use black and white images, false: use color images
  let isInteract = true; // true: can manipulate data, false: produces all chart variations
  let emNum = 4; // 0-4, create charts that are 0:norm, 1:norm2, 2:un, 3:un2, 4:emb

  // ----------------- BEGIN: Example Data ----------------------------//

  exAccessors=['year','cornSales']
  exData=[
    {'year': 2002, 'cornSales': 1.7052}, {'year': 2003, 'cornSales': .618}, {'year': 2004, 'cornSales': .492}, {'year': 2005, 'cornSales': .3144},
    {'year': 2006, 'cornSales': .3048}, {'year': 2007, 'cornSales': .2736}, {'year': 2008, 'cornSales': .936}, {'year': 2009, 'cornSales': 4.4436},
    {'year': 2010, 'cornSales': 2.4456}, {'year': 2011, 'cornSales': 1.3356}, {'year': 2012, 'cornSales': 1.7472}
  ]
  // Example of how the JSON file being read is formatted.
  exImage={'interact':{
            "key": "recession",
            "withIcon": false,
            "imagePath": [
                "modules/graphQuestions/examples/line_interact_01_ex.png",
                "modules/graphQuestions/examples/line_interact_00_ex.png"
            ],
            "imagePathBW": [
                "modules/graphQuestions/examples/line_bw_interact_01_ex.png",
                "modules/graphQuestions/examples/line_bw_interact_00_ex.png"
            ],
            'accessors': exAccessors,
            "imageDim": [ 552, 339 ],
            'baseDim': [2200, 1500],
            "sortedChoices": { "unrelated": [ "Poison in Water", "Food Poisening", "Exploitive News" ] },
            'pointLoc': 7,
            'gridLines': [2, 4, 0],
            'gridColor': ['black', 'black'],
            'gridPadding': [0, 0],
            'yGridVal': 1.2,
            'lineCol': 'black',
            'data': exData
    }
  }

  // ----------------- END: Example Data ----------------------------//
  // ----------------- BEGIN: Chart Variables ----------------------------//

  var chart;

  // Not sure what this does? Guess it sets the ratio of width to height?
  let perc = [1, .8]

  // If I remove the inital line of declaration, the style is thrown off.
  var bodyDim = {w:parseInt(d3.select('#graphIImage').style('width'), 10)*perc[0], h:parseInt(d3.select('#graphIImage').style('height'), 10)*perc[1]}
  bodyDim.h = 500*perc[1]
  bodyDim.w = 850*perc[0]
  // console.log("bod", bodyDim)

  // For when I wanted to edit the icon locations on the pie.
  // I do not think this is needed. s
  let pieEdit = 0;

  var data = {}
    , graphCounter = 0 // Count of the current chart
    , lastGraph = false // boolean for whether or not the last chart
    , isValid = true // Will not be able to PROCEED if !skip and !isValid, currenlty not being used.
    , graphArray = [] // The array of all the chart data to create the charts.
    , storyData; // The current chart data

  // ----------------- END: Chart Variables ----------------------------//
  // ----------------- BEGIN: Helper Functions ----------------------------//

  function clampThings(num, min, max){return Math.min(Math.max(num, min), max)}

  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  }
  // ----------------- END: Helper Functions ----------------------------//
  // ----------------- BEGIN: Setup Data Functions ----------------------------//

  let embT = ["normal", "normal2", "unrelated", "unrelated2", "embellished"]
  function notInteract(gO, gArr){
    for (var i in gO){
      for (let j=0; j<gO[i].length; j++){
        for (let k=0; k<embT.length; k++){
          gArr.push(gO[i][j])
          gArr[gArr.length-1].embType=embT[k]
          gArr[gArr.length-1].chartType=i
        }
      }
    }
    console.log(gArr)
  }

  // Getting information for line and bar charts.
  function setImg(embType, data, iDim){
    // embellished, unrelated, normal
    let outData = {}
    let rat = data.interact.imageDim[0]/data.interact.imageDim[1]
    let dim = new Array(2)
    // Getting the largest (w,h) and setting to bodyDim and then setting smaller based on proportion
    dim[0]=rat>1?bodyDim.w:rat*bodyDim.h
    dim[1]=rat>1?1/rat*bodyDim.w:bodyDim.h
    // PlotArea will be the plot area and could be the dimensions if embellished
    data.interact.plotArea=dim
    // console.log("dimIs", dim)
    // Get the smallest dimension and set to either the width or height depending
    // ImageDim will actually be the dimensions
    if (embType == "embellished"){
      data.interact.imageDim=dim
    } else {
      // Getting the smallest (w,h) and setting to bodyDim and then setting bigger based on proportion
      let smallInd = iDim[0]/iDim[1]<1?0:1
      let largeInd = smallInd==0?1:0
      data.interact.imageDim[0]=iDim[0]/iDim[1]<1?dim[0]:iDim[0]/iDim[1]*dim[1]
      data.interact.imageDim[1]=iDim[0]/iDim[1]<1?iDim[1]/iDim[0]*dim[0]:dim[1]
      // Checking to see if the largest dimension is greater than the plotArea, if not adjust
      if (data.interact.imageDim[largeInd]<dim[largeInd]) {
        let perc = dim[largeInd]/data.interact.imageDim[largeInd]
        data.interact.imageDim[largeInd]=data.interact.imageDim[largeInd]*perc
        data.interact.imageDim[smallInd]=data.interact.imageDim[smallInd]*perc
      }
    }
  }

  function setBars(isBarDim, barDim, imageDim, numBars){
    // Using the bar dimensions to find out how much padding is needed for the the rangeBands scale.
    let padding = 0
    if (isBarDim){
      let barH = barDim[1]/barDim[0]*imageDim[0]
      padding = 1 - (barH*numBars)/imageDim[1]
      padding = padding > .05? padding:.05
    } else {
      padding = .4
    }
    return padding
  }

  // A dictionary for relating how the user chart(graph) order and information was saved to how it is labeled in the files.
  let embDict = {normal: "norm_01", normal2: "norm_02", unrelated: "unrelated_01", unrelated2: "unrelated_02", embellished: "embellished"}

  function getData(gArr){
    // Loading the files
    let graphO, graphA, graphI
    d3.json('modules/graphQuestions/data.json', function(err, d) {graphA = d})
    // d3.json('modules/graphOrder.json', function(err, d) {graphO = d})
    d3.json('modules/graphQuestions/interactData.json', function(err, d) {graphI = d})
    graphO = experimentr.graphOrder
    // console.log('graphO', graphO)

    // Do something after a few seconds / the data is loaded.
    setTimeout(()=>{
      // if (graphO[0].isBW!=null)
      //   isBW = graphO[0].isBW
      // else {isBW = isBW}
      if (isInteract){
        // Set the graph array based on chart(graph) order saved from the first session.
        for (let i=0; i<graphO.length; i++){
          // console.log('iGOL', graphO.length)
          gArr.push(graphA[graphO[i].chartType].filter((d2)=>{return d2.key==graphO[i].key})[0])
          // Set the chart and embellishment type to that of the first session.
          gArr[i].embType = graphO[i].embType
          gArr[i].chartType = graphO[i].chartType
        }
      } else {
          // Set the graph array to include each dataset for the selected embellishment type (emNum)
          for (let i in graphA){
            for (let j=0; j<graphA[i].length; j++){
              gArr.push(Object.assign({}, graphA[i][j], {embType:embT[emNum], chartType:i}))
            }
          }
      }
      // Get the associated data based on CSV files
      for (let i = 0; i < gArr.length; i++){
        if (isBW) {
          gArr[i].interact.imagePath = gArr[i].interact.imagePathBW
          if (gArr[i].interact.imagePathBW==null)
            console.log('garr', gArr[i].key, gArr[i].title)
          gArr[i].interact.colorArray = gArr[i].interact.bwArray
        }
        d3.csv(gArr[i].interact.dataPath, function(iData){
          // Setting the accessors based on the column and row data
          gArr[i].interact.accessors = [d3.keys(iData[0])[0], d3.keys(iData[0])[1]]
          // Turning the strings into floats for the values
          iData.map((d)=>{
    				d[gArr[i].interact.accessors[1]]= parseFloat(d[gArr[i].interact.accessors[1]])
    			})
          // Adding data to the main graph array
          gArr[i].interact.data = iData
        })
      }
      for (let i = 0; i < gArr.length; i++){
        // Set the embellished charts
        if (gArr[i].embType=="embellished") {
          if (gArr[i].chartType!="pie")
            setImg(gArr[i].embType, gArr[i], gArr[i].interact.imageDim)
          if (gArr[i].chartType=="bar")
            gArr[i].interact.padding=setBars(gArr[i].embType=="embellished", gArr[i].interact.barDim, gArr[i].interact.plotArea, gArr[i].interact.imagePath.length-1)
          if (isBW){
            if (gArr[i].chartType=="line"){
                gArr[i].interact.gridColor=["black", "#2a2d33"]
                gArr[i].interact.lineCol = "black"
            } else if (gArr[i].chartType=="bar") {
              gArr[i].interact.xGridCol=["black", "#2a2d33"]}
          }
          continue;
        }
        // Set the unrelated and normal images
        let newData = graphI[gArr[i].chartType][embDict[gArr[i].embType]]
        if (gArr[i].chartType=="line"){
          gArr[i].interact.gridColor=["black", "#2a2d33"]
          gArr[i].interact.lineCol = "black"
          newData=newData[0]
          if (isBW){
            gArr[i].interact.imagePath = newData.imagePathBW
          } else {gArr[i].interact.imagePath = newData.imagePath}
          gArr[i].interact.withIcon = newData.withIcon
          if (newData.withIcon){
            gArr[i].interact.iconDim=newData.iconDim
            gArr[i].interact.iconLoc=newData.iconLoc
          }
          // Note: Might have to go through and look at the keys of object and see if want to copy all, for now hardcoded...
        } else {
          gArr[i].interact.xGridCol=["black", "#2a2d33"]
          newData=newData.filter((d2)=>{
            return d2.imagePath.length==gArr[i].interact.imagePath.length})[0]
          console.log("n1e",newData)
          if (isBW){
            gArr[i].interact.imagePath = newData.imagePathBW
          } else {gArr[i].interact.imagePath = newData.imagePath}
          if (gArr[i].chartType=="bar"&&newData.useBG){gArr[i].interact.imageDim=newData.imageDim}
          if (gArr[i].chartType=="pie"){
            gArr[i].interact.withIcon=newData.withIcon
            gArr[i].interact.colorArray= isBW? newData.bwArray:newData.colorArray
          }
        }
        if (gArr[i].chartType!="pie")
          setImg(gArr[i].embType, gArr[i], newData.imageDim)
        if (gArr[i].chartType=="bar")
          gArr[i].interact.padding=setBars(gArr[i].embType=="embellished", gArr[i].interact.barDim, gArr[i].interact.plotArea, gArr[i].interact.imagePath.length-1)
          gArr[i].interact.barDim=newData.barDim
      }
      // Pushing an object for each dataset to collect data.
      for (let i=0; i<graphArray.length; i++){
          mod4.push({key: graphArray[i].chartType, inputData: []})
      }
    }, 500)
  }
  // ----------------- END: Setup Data Functions ----------------------------//
  // ----------------- BEGIN: INITIALIZE SCRIPT ----------------------------//

  init(); // Initialize everything!!!!

  function init() {
    experimentr.hideNext(); // Hides the next button
    experimentr.startTimer('graphInteract'); // Starts the timer for the entire module.

    if(experimentr.isBW!=null){isBW = experimentr.isBW} else {isBW = isBW}

    tutTime = true;

    getData(graphArray) // Get the data for all of the charts.
    console.log("GRAPH ARRAY", graphArray)

    // Starting the module with an example as part of the instructions.
    storyData = exImage
    if (isBW){
      storyData.interact.imagePath = storyData.interact.imagePathBW
    }
    setImg('ex', exImage, exImage.interact.baseDim)
    // Note: 400 is coming from the max height of the svg containing interact image
    d3.select('#graphIImage').append('img').attr('src', ()=>{
      if (isBW){return 'modules/graphQuestions/examples/example_bw_mod4.png'} else {
        return 'modules/graphQuestions/examples/example_mod4.png'
      }
    })
      .attr("height", perc[1]*100*.7+"%")
      .attr("width", perc[1]*100*.7*exImage.interact.plotArea[0]/exImage.interact.plotArea[1]+'%').style('object-fit', 'contain')
      .attr('class', 'lineGraph').style('max-height', 400*(isInteract? .9:1)+'px').style('object-position', '0 0')
    makeLine();

    // Text instructions
    d3.select('#graphIInstructions').selectAll("*").remove()
    d3.select('#graphIInstructions').append('strong').text("Please read the following instructions.").append("br")
    d3.select('#graphIInstructions').append('text').text("Use the up and down arrow buttons to change the value of the graph to match your memory of the graphs").append("br")

    // A button for the participant to proceed after a certain amount of time (seconds)
    setTimeout(function(){
      d3.select('#graphIText').append('button')
        .attr('type', 'button').style("margin-top", '20px')
        .text('Proceed')
        .on('click',
          function(d) {
            tutTime = false;
            loadData();
          });
    }, 1000)
  }
  // ----------------- END: INITIALIZE SCRIPT ----------------------------//
  // ----------------- BEGIN: LOAD CHART INFORMATION ----------------------------//

  function loadData() {
    isValid = true

    if (graphCounter == graphArray.length-1){
        lastGraph = true;
    }
    storyData = graphArray[graphCounter];
    loadImage();
  }

  function loadImage() {
    d3.select('#graphIInstructions').selectAll("*").remove();
    d3.select("#graphIInstructions").append("strong")
      .text("Please use arrow keys to adjust the graph to memory.")
    d3.select('#interactButtons').selectAll("*").remove();
    d3.select('#interactButtons').html("<br><text>Use buttons to visually adjust the value of the chart.<text><br>")
    d3.select('#graphIImage').selectAll("*").remove()

    console.log("loading", storyData.interact)

    switch (storyData.chartType) {
      case "line":
        makeLine();
        break;
      case "pie":
        makePie();
        break;
      case "bar":
        makeFunBar();
        break;
      default:
        makePower();
        break;
    }
    mod4[graphCounter].timeQStart=new Date().getTime() // Recording the start time of the chart
    loadQuestion();
  }

  // In the case that chartType was not correct, show power ranger
  function makePower() {
    d3.select('#graphIImage').append('img')
      .attr('class', 'picture')
      .attr('src', function(d) { return "modules/graphQuestions/graphImages/color/rangerPoseGreen.png"; })
      .style('height', perc[1]*100+"%")
      .style('width', 'auto')
  }

  function loadQuestion() {
    d3.select('#graphIInstructions').selectAll("*").remove();
    if (skip) {d3.select('#graphIInstructions').append("strong").text(storyData.title+" - "+storyData.embType)}
    d3.select('#graphIText').selectAll("*").remove();
    if (!lastGraph){
      d3.select('#graphIText').append('button')
        .attr('type', 'button')
        .text('Confirm Answer')
        .on('click',
          function(d) {
            if (isValid || skip){
              mod4[graphCounter].timeQEnd=new Date().getTime()
              d3.select('#graphIVerification').selectAll("*").remove()
              graphCounter++;
              clearTimeout(chart.timer); // In case there were pending chart changes, stop them.
              validate(); // This should send to the server.
              loadData();
            }
          });
    } else {
      // This is the last chart, rather than confirm answer, the next module button will appear.
      if (skip){
        mod4[graphCounter].timeQEnd=new Date().getTime()
        validate()
      }
      experimentr.release();
      experimentr.showNext();
    }
  }

  // ----------------- END: LOAD CHART INFORMATION ----------------------------//
  // ----------------- BEGIN: MAKE BAR CHARTS ----------------------------//

  function makeFunBar(){
    let barData = storyData.interact.data
    let labelArray = barData.map((d)=>{return d[storyData.interact.accessors[0]]})

    // --- Set up chart ---//
    // Make the SVG
    chart = d3.select('#graphIImage').append("svg").attr("class", "bar")

    // The bar being manipulated
    chart.selBar = storyData.interact.selBar-1
    // console.log("labArray", labelArray, storyData.interact.selBar-1)

    // bodyDim-> the dimensions of the chart
    chart.bodyDim = {w: storyData.interact.plotArea[0]*1, h: storyData.interact.plotArea[1]*1}
    // imageDim-> the dimensions of the images, that will be cropped by the body dimensions
    chart.imageDim = {w: storyData.interact.imageDim[0]*1, h: storyData.interact.imageDim[1]*1}
    console.log('bar-bodyDim, bar-imageDim', chart.bodyDim, chart.imageDim)
    // Other than attributing to the SVG viewbox, no use.
    chart.arrowSize = bodyDim.w * (1-.8-.05)

    // Update the SVG to match dimensions
    chart
      .attr("viewBox", "0 0 "+(chart.bodyDim.w+chart.arrowSize).toString()+" "+(chart.bodyDim.h).toString())
      .attr("preserveAspectRatio", "xMinYMax meet")
      .attr('height', perc[1]*100+"%")
      .attr('width', perc[0]*100+"%")

    // --- Set up scales ---//
    // Using the preprocessed JSON data to use as the padding between bars
    let padding = storyData.interact.padding

    chart.yScale = d3.scale.ordinal()
      .domain(labelArray)
      .rangeBands([0, chart.bodyDim.h], padding) // [0,h] bc the bars are ordered top down

    chart.barHeight = chart.yScale.rangeBand() // using the scale to get the height of each bar (really is the band width)

    chart.xScale = d3.scale.linear()
      // .domain([0, 135])
      .domain([0, storyData.interact.xGridMax])
      .range([0, chart.bodyDim.w])

    // Setting the bar to be manipulated to half of the domain.
    if (isInteract){
      barData[chart.selBar][storyData.interact.accessors[1]]=chart.xScale.domain()[1]/2 }

    // Image size is dictated by the smallest variable. Since the arrow can be square shaped, using barheight for width as well.
    // This is flawed by the determination of the viewbox. If the width exceeded the viewbox, the arrow would not be in view.
    // Width has to be specified as Firefox likes it.
    // TODO: Somewhere there is a CSS property that keeps the propertions the same.
    chart.append("image")
      .attr("xlink:href", 'modules/graphInteract/buttons/left.png')
      .attr("height", chart.barHeight)
      .attr("width", chart.barHeight)
      .attr("x", chart.bodyDim.w+5) // Attaching it five pixels to the right of the charts
      .attr("y", chart.yScale(barData[chart.selBar][storyData.interact.accessors[0]])) // Attaching it to the bar height

    // Appending the buttons for controlling the width of the bars.
    for (let i =0; i<2; i++){
      let buttonType = i==0? "up" : "down"
      let isInc = i==0
      d3.select('#interactButtons').append("button")
        .attr("class", "button1 "+buttonType)
        .on("mousedown", ()=>{
          chart.glowBar.style("opacity", 1) // highlight selected bar
          chart.inc=setInterval(function(){ incBar(isInc, .001*chart.xScale.domain()[1]) }, 25) // call function after 25/1000 seconds
          clearTimeout(chart.timer);
        })
        .on('mouseup', ()=>{
          clearInterval(chart.inc) // clear function call if mouse lets go of button.
          chart.timer=setTimeout(()=>{
            chart.glowBar.style("opacity", .2)
            if (lastGraph){mod4[graphCounter].timeQEnd=new Date().getTime()}
          }, 500)
        })
        .on('mouseout', ()=>{
          clearInterval(chart.inc) // clear function call if mouse leaves button area
          chart.timer=setTimeout(()=>{
            chart.glowBar.style("opacity", .2) // reduce opacity of highlight on selected bar
            if (lastGraph){mod4[graphCounter].timeQEnd=new Date().getTime()}
          }, 500)
        })
    }

    // Append BG Image
    chart.append("image")
      .attr("class", "clip-chartArea")
      .attr("xlink:href", storyData.interact.imagePath[0])
      .attr("height", chart.imageDim.h)
      .attr("width", chart.imageDim.w)
      .attr("y", chart.bodyDim.h-chart.imageDim.h) // makes sure the chart is positioned from the top of the image

    // Add vertical gridlines
    let vData = []
    let vLine = storyData.interact.xGrid[0]
    let mLine = storyData.interact.xGrid[1]
    for (let i = 0; i < vLine+1; i++){
      if (((i+1)*chart.xScale(storyData.interact.xGridStep))>chart.xScale.range()[1]){continue;}
      vData.push({col: "grey", xPos: (i+1)*chart.xScale(storyData.interact.xGridStep)})
      for (let j = 0; j < mLine; j++){
        if (((i)*chart.xScale(storyData.interact.xGridStep)+(chart.xScale(storyData.interact.xGridStep))/(mLine+1)*(j+1))>chart.xScale.range()[1]){continue;}
        // hData.push({col: storyData.interact.gridColor[1], yPos: chart.yScale.range()[0]/(hLine+1)*(i)+chart.yScale.range()[0]/(hLine+1)/(mLine+1)*(j+1)})
        vData.push({col: "lightgrey", xPos: (i)*chart.xScale(storyData.interact.xGridStep)+(chart.xScale(storyData.interact.xGridStep))/(mLine+1)*(j+1)})
      }
    }
    chart.yGrid = chart.append("g").attr("class", "yGrid")
      .selectAll("line")
      .data(vData)
      .enter().append("line")
      .attr("x1", (d)=>{return d.xPos})
      .attr("x2", (d)=>{return d.xPos})
      .attr("y1", (d)=>{return chart.yScale.rangeExtent()[1]})
      .attr("y2", (d)=>{return chart.yScale.rangeExtent()[0]})
      .style("stroke", (d)=>{return d.col})

    console.log("b", barData[chart.selBar])

    // Add the outline bar
    if (isInteract){
      chart.glowBar = chart.append("rect")
        .attr("y", chart.yScale(barData[chart.selBar][storyData.interact.accessors[0]])-8/2)
        .attr("height", chart.barHeight+8)
        .attr("width", chart.xScale(barData[chart.selBar][storyData.interact.accessors[1]]))
        .attr("fill", "fuchsia")
        .style("opacity", .2)
    }

    let barGrp =chart.append("g").selectAll("image")
      .data(barData).enter()
    chart.chartBars = chart.append("g").selectAll("image")
      .data(barData).enter()
    chart.chartBars = barGrp
      .append("image")
      .attr("class", (d, i)=>{
        return "bar_"+i+" "+"clip-svg"+(i+1).toString()
      })
      // .attr("href", (d, i)=>{return 'modules/graphQuestions/graphImages/interactBars/bar_interact1_0'+(i+1)+'_artwork.png'})
      .attr("xlink:href", (d, i)=>{return storyData.interact.imagePath[i+1]})
      .attr("height", chart.barHeight)
      .attr("width", chart.barHeight*storyData.interact.barDim[0]/storyData.interact.barDim[1])
      .attr("y", (d)=>{return chart.yScale(d[storyData.interact.accessors[0]])})
      .attr("preserveAspectRatio", "none")

    // Add the clipping paths
    chart.barClip = chart.append("defs").selectAll("clipPath")
      .data(barData).enter().append("clipPath")
      .attr("id", (d,i)=>{return "clipper"+(i+1).toString()})
      .append("rect")
      .attr("y", (d)=>{return chart.yScale(d[storyData.interact.accessors[0]])})
      .attr('height',chart.barHeight)
      .attr('width', (d,i)=>{return chart.xScale(d[storyData.interact.accessors[1]])})

    chart.append("g")
      .append("clipPath")
      .attr("id", "clipperChartArea")
      .append("rect")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", chart.bodyDim.w)
      .attr("height", chart.bodyDim.h)

    chart.chartOutline = chart.append("g")
      .attr("class", "barOutline")
      .append("rect")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", chart.bodyDim.w)
      .attr("height", chart.bodyDim.h)

    chart.chartVertical = barGrp
      .insert("line")
      .attr("class", "barEdge")
      .attr("x1", (d)=>{return chart.xScale(d[storyData.interact.accessors[1]])})
      .attr("x2", (d)=>{return chart.xScale(d[storyData.interact.accessors[1]])})
      .attr("y1", (d)=>{return chart.yScale(d[storyData.interact.accessors[0]])})
      .attr("y2", (d)=>{return chart.yScale(d[storyData.interact.accessors[0]])+chart.barHeight} )
      // .attr("stroke", "black")

    mod4[graphCounter].inputData.push({'userAnswer':barData[chart.selBar][storyData.interact.accessors[1]]})

  }

  function incBar(isInc, step){
    // Making sure the bar does not exceed the 0 and 1.
    let bar = storyData.interact.data[chart.selBar]
    bar[storyData.interact.accessors[1]] = clampThings((isInc? bar[storyData.interact.accessors[1]]+step : bar[storyData.interact.accessors[1]]-step), 0, chart.xScale.domain()[1])
    // console.log(bar[storyData.interact.accessors[1]], bar)
    // Updating the clipping path.
    chart.glowBar.attr('width', chart.xScale(bar[storyData.interact.accessors[1]]))
    d3.select("#clipper"+(chart.selBar+1).toString()).select("rect").attr("width", (d)=>{return chart.xScale(d[storyData.interact.accessors[1]])})
    // .attr("id", (d,i)=>{return "clipper"+(i+1).toString()})
    // chart.chartBars.select(".bar_"+chart.selBar).attr("width", (d)=>{return chart.xScale(d[storyData.interact.accessors[1]])})
    // console.log("cha", chart.chartVertical)
    chart.chartVertical.attr("x1", (d)=>{return chart.xScale(d[storyData.interact.accessors[1]])}).attr("x2", (d)=>{return chart.xScale(d[storyData.interact.accessors[1]])})

    if(!tutTime) {
      mod4[graphCounter].inputData[0].userAnswer = bar[storyData.interact.accessors[1]]
    }

  }

    // ----------------- END: MAKE BAR CHARTS ----------------------------//

  function makePie() {
    let pieData = storyData.interact.data
    let accessors = storyData.interact.accessors
    let piePerc = 1

    // Setting the chart
    chart = d3.select('#graphIImage')
    // Setting the width to almost 70 to give room for legend...though legend might not be necessary in future iterations...
    chart.bodyDim = {w:bodyDim.w*.65, h: bodyDim.h}
    console.log("pieTime", storyData, chart.bodyDim)
    // I'm thinking of placing this up in the switch statement area and having the function be a variable based on switch.
    // Redudant for now
    // Or add a variable to inc function and do something based on that...
    for (let i =0; i<2; i++){
      let buttonType = i==0? "up" : "down"
      let isInc = i==0
      d3.select('#interactButtons').append("button")
        // .style("height", (100*(1-perc[1])).toString()+"%")
        .attr("class", "button1 "+buttonType)
        .on("mousedown", ()=>{
          chart.highSlice.style("opacity", 1)
          chart.inc=setInterval(function(){ incSlice(isInc, .15) }, 25)
          clearTimeout(chart.timer);
        })
        .on('mouseout', ()=>{
          clearInterval(chart.inc)
          chart.timer=setTimeout(()=>{
            chart.highSlice.style("opacity", .4)
            if (lastGraph){mod4[graphCounter].timeQEnd=new Date().getTime()}
          }, 500)
        })
        .on('mouseup', ()=>{
          clearInterval(chart.inc)
          chart.timer=setTimeout(()=>{
            chart.highSlice.style("opacity", .4)
            if (lastGraph){mod4[graphCounter].timeQEnd=new Date().getTime()}
          }, 500)
        })
    }
    // Setting a color scale if not predefined.
    chart.colorScale = d3.scale.category10()
      // .attr("height", chart.bodyDim.h)

    // Getting the minimum chart Dimensions and setting it as the diameter of the circle.
    let dia  = Math.min(chart.bodyDim.w, chart.bodyDim.h)

    // Create the SVG
    chart.plotArea = chart.append("svg").attr("class", "pie")
      .attr('width', perc[0]*100*piePerc+"%")
      .attr('height', perc[1]*100+"%")
      .attr("viewBox", ((chart.bodyDim.w-dia)/2).toString()+" "+((chart.bodyDim.h-dia)/2).toString()+" "+(dia).toString()+" "+(dia).toString())
      .attr("preserveAspectRatio", "xMinYMax meet")
      // .attr("viewBox", "0 0 "+(bodyDim.w).toString()+" "+(bodyDim.h).toString())

    // Appending a group for random SVG elements and dimensions
    chart.pieArea = chart.plotArea.append("g")

    chart.pieArea.r = dia / 2 * .85
    chart.arrowSize  = dia/2*.15

    chart.pieArea.raySize = chart.pieArea.r*.7
    let raySize = chart.pieArea.raySize
    chart.legendArea = chart.append("table").attr('class','legend pie')
      .attr('width', perc[0]*100*(1-piePerc)+"%")
      // .style("margin-top", (chart.pieArea.r).toString()+"px").append("tbody")

    // The arc function to specify the paths for the pie.
    var arc = d3.svg.arc().outerRadius(chart.pieArea.r - 10).innerRadius(0);

    // Modifying the pie slices so that the main slice starts at 180
    if (isInteract){
      let oValue = pieData[storyData.interact.pointLoc][accessors[1]]
      let halfSum = pieData.reduce((sum, value)=>{
        return sum+value[accessors[1]]}, 0).toFixed(2)/2
      console.log('halfSum', halfSum)
      for (let i = 0; i <pieData.length; i++){
        if (i == storyData.interact.pointLoc){
            pieData[i][accessors[1]]=halfSum
            console.log('main', i,'-',pieData[i][accessors[1]])
        } else {
          // pieData[i][accessors[1]]=pieData[i][accessors[1]]+(oValue - halfSum)/(pieData.length-1)
          pieData[i][accessors[1]]=pieData[i][accessors[1]]+(oValue - halfSum)*pieData[i][accessors[1]]/(100-oValue)
          console.log('each', i, '-', pieData[i][accessors[1]])
        }
      }
    }

    // Saving the pieSlice value, which should be 1/2 of the sum
    // mod4[graphCounter].value = pieData[storyData.interact.pointLoc][accessors[1]]
    mod4[graphCounter].inputData.push({'userAnswer':pieData[storyData.interact.pointLoc][accessors[1]]})

    // A function to specify the angles of the pie.
    var pie = d3.layout.pie(pieData).sort(null).value(function(d) { return d[accessors[1]]; });

    // get the min pie slice
    let pieMin = 0
    let pieTestRange = changeAllSlices? pieData.length : 3
    for (let i = 0; i < pieTestRange; i++){
    // for (let i = 0; i < 3; i++){
      if (i==0){chart.pieMin = i; pieMin=pieData[i][accessors[1]]}
      else if (i!=1&&pieMin>pieData[i][accessors[1]]){
        pieMin = pieData[i][accessors[1]]
        chart.pieMin=i
        console.log("i", i)
      }
    }

    // Creating pie slices
    var pieInfo = pie(pieData)

    // Add pie make here
    if (storyData.interact.withIcon){
      // The clipping paths for the icons.
      chart.pieArea
        .selectAll("path")
        .data(pie(pieData)).enter()
        .append("defs").append("clipPath")
        .attr("id", function(d,i){
          return "clipper"+(i+1).toString()
          })
        .append("path")
        .attr("transform", "translate("+chart.bodyDim.w/2+","+chart.bodyDim.h/2+")")
          .attr("d", arc)
          .style("fill", function(d, i) { return chart.colorScale(i); })
          .each(function(d) { this._current = d; })
      // console.log("pie", pieInfo)

      // The base color
      chart.plotArea.append("g")
        .attr("class", "outline")
        .selectAll("path")
        // .remove().exit()
        .data(pie(pieData)).enter()
        .append("path")
        .attr("transform", "translate("+chart.bodyDim.w/2+","+chart.bodyDim.h/2+")")
          .attr("d", arc)
          .style("fill", (d,i)=>{return storyData.interact.colorArray[i]})
          .style("stroke", "none")
          // .style("stroke-width", 3)
          .each(function(d) { this._current = d; })

      // Creating icons
      // console.log("bodyDim", chart.bodyDim, chart.pieArea.r)
      imgCon = {max: chart.pieArea.r*.6, min: 50}
      chart.pieArea.imgCon = imgCon
      chart.pieArea.icons=chart.plotArea.append("g")
        .attr("class", "icons")
        .selectAll("image")
        .data(storyData.interact.imagePath)
        .enter().append("image")
          .attr("align", "center")
          .attr("xlink:href", (d)=>{return d.path})
          .attr("class", (d,i)=>{return "clip-svg"+(i+1).toString()})
          // .style("width", 100)
          // .style("height", 100)
          .attr("width", (d,i)=>{
            // Check if the angle is greater than 180
            if (pieInfo[i].endAngle-pieInfo[i].startAngle<Math.PI){
              var xChange = Math.pow(Math.cos(pieInfo[i].endAngle)-Math.cos(pieInfo[i].startAngle),2)
              var yChange = Math.pow(Math.sin(pieInfo[i].endAngle)-Math.sin(pieInfo[i].startAngle),2)
              // console.log("x", xChange, yChange)
              d.width = clampThings(Math.sqrt(xChange+yChange)*raySize*.8, imgCon.min, imgCon.max)
            } else {d.width = imgCon.max}
            d.raySize = chart.pieArea.r - d.width*.65 -10
            // d.width = Math.min(Math.max(Math.sqrt(xChange+yChange)*raySize, imgCon.min), imgCon.max)
            // console.log("s", d.width, imgCon, Math.sqrt(xChange+yChange)*raySize, clampThings(Math.sqrt(xChange+yChange)*raySize, imgCon.min, imgCon.max))
            return d.width
          })
          .attr("height", (d, i)=>{return d.width})
          .attr("x", (d, i)=>{
            d.xPos = Math.cos((pieInfo[i].endAngle-pieInfo[i].startAngle)/2+pieInfo[i].startAngle-1.57)*d.raySize+chart.bodyDim.w/2-d.width/2
            // return Math.cos((pieInfo[i].endAngle-pieInfo[i].startAngle)/2+pieInfo[i].startAngle-1.57)*raySize+chart.bodyDim.w/2-d.width/2
            return d.xPos
              // console.log("d", d, pieInfo[i])
          })
          .on("click", (d)=>{
            pieEdit=pieEdit+1<3?pieEdit+1:0
            console.log("de", pieEdit)
          })
          .attr("y", (d, i)=>{return d.yPos=Math.sin((pieInfo[i].endAngle-pieInfo[i].startAngle)/2+pieInfo[i].startAngle-1.57)*d.raySize+(chart.bodyDim.h/2-d.width/2)})
          .call(d3.behavior.drag().on("drag", function(d){
              d3.select(this).attr("x", (d)=>{return d3.event.x-d.width/2}).attr("y", (d)=>{return d3.event.y-d.width/2})
          }))
    } else {
      // Draw the pie slices.
      chart.pieArea
        .selectAll("path")
        // .remove().exit()
        .data(pie(pieData)).enter()
        .append("defs").append("clipPath")
        .attr("id", function(d,i){
          return "clipper"+(i+1).toString()
          })
        .append("path")
        // I need to put transform here to have the group in the same coordinates as the clipping path.
        .attr("transform", "translate("+chart.bodyDim.w/2+","+chart.bodyDim.h/2+")")
        // .transition().delay(100)
          .attr("d", arc)
          .style("fill", function(d, i) { return chart.colorScale(i); })
          .each(function(d) { this._current = d; })

      var imgD = chart.pieArea.r*2

      var fileNames = ["potatoes", "pita", "fries", "rice", "tortillaBrown"]
      for (let i = 0; i < storyData.interact.imagePath.length; i++){
        if (i>pieData.length-1){continue;}
        chart.plotArea.append("g")
          .attr("class", "clip-svg"+(i+1).toString())
          // .append("image").attr("href", "/data/land.png").style("width", "auto").style("height", "100%")
          .append("image").attr("xlink:href", storyData.interact.imagePath[i].path)
          .attr("width", imgD).attr("height", imgD)
          .attr("x", chart.bodyDim.w/2-storyData.interact.imageDim[1]/storyData.interact.imageDim[0]*chart.pieArea.r)
          .attr("y", chart.bodyDim.h/2-storyData.interact.imageDim[0]/storyData.interact.imageDim[1]*chart.pieArea.r)
          .style("position", "absolute")
      }
    }
    // This is responsible for the outline of the pie slices
    chart.plotArea.append("g")
      .attr("class", "outline")
      .selectAll("path")
      // .remove().exit()
      .data(pie(pieData)).enter()
      .append("path")
      // I need to put transform here to have the group in the same coordinates as the clipping path.
      .attr("transform", "translate("+chart.bodyDim.w/2+","+chart.bodyDim.h/2+")")
      // .transition().delay(100)
        .attr("d", arc)
        .style("fill", "none")
        .style("stroke", "black")
        .style("stroke-width", 3)
        .each(function(d) { this._current = d; })

    // Highlights the slice being changed
    if (isInteract){
      console.log('sto',storyData.interact.pointLoc)
      chart.highSlice = chart.plotArea.append("g")
        .attr("class", "highlight")
        .append("path").datum(pie(pieData)[storyData.interact.pointLoc])
        // .append("path").datum(pie(pieData)[1])
        .attr("transform", "translate("+chart.bodyDim.w/2+","+chart.bodyDim.h/2+")")
          .attr("d", arc)
          .style("fill", "none")
          .style("stroke", "#FF1493")
          .style("stroke-width", 3)
          .style("opacity", .4)



      // Sets and arrow image pointing at pie slice being changed.
      // let p = 1
      let p = storyData.interact.pointLoc
      let pointerCoor = [Math.cos((pieInfo[p].endAngle-pieInfo[p].startAngle)/2+pieInfo[p].startAngle-1.57)*(chart.pieArea.r+chart.arrowSize/4)*(1)+chart.bodyDim.w/2-chart.arrowSize/2
        , Math.sin((pieInfo[p].endAngle-pieInfo[p].startAngle)/2+pieInfo[p].startAngle-1.57)*(chart.pieArea.r+chart.arrowSize/4)*1+(chart.bodyDim.h/2-chart.arrowSize/2)]
      let pAngle = (pieInfo[p].endAngle-pieInfo[p].startAngle)/2 + pieInfo[p].startAngle
      // console.log(pAngle*180/Math.PI, pieInfo[1].startAngle*180/Math.PI, pieInfo[1].endAngle*180/Math.PI)
      chart.arrow = chart.plotArea.append("g")
        .attr("class", "arrowPointer")
        .append("image").attr("xlink:href", "modules/graphInteract/buttons/up.png")
        .attr("width", chart.arrowSize).attr("height", chart.arrowSize)
          .attr("transform", "rotate("+(pAngle*1*180/Math.PI+180).toString()+" "+(pointerCoor[0]+chart.arrowSize/2)+" "+(pointerCoor[1]+chart.arrowSize/2)+")")
        .attr("x", (d, i)=>{
          return pointerCoor[0]
            // console.log("d", d, pieInfo[i])
        })
        .attr("y", (d, i)=>{return pointerCoor[1]})
        // .attr("x", chart.bodyDim.w/2-storyData.interact.imageDim[1]/storyData.interact.imageDim[0]*chart.pieArea.r)
        // .attr("y", chart.bodyDim.h/2-storyData.interact.imageDim[0]/storyData.interact.imageDim[1]*chart.pieArea.r)
    }
  }

  function incSlice (isInc, inc){
    let pieData = storyData.interact.data
    let accessors = storyData.interact.accessors
    // If increasing the slice and if other slices are not being zeroed out
    if (isInc && pieData[chart.pieMin][accessors[1]]>inc/(100-pieData[chart.pieMin][accessors[1]])){
    // if (isInc && pieData[chart.pieMin][accessors[1]]>inc/(pieData.length-1)){
      editPie(true)
    } else if (!isInc && pieData[storyData.interact.pointLoc][accessors[1]]>inc) {
      // If decreasing the slice and the slice is not being zeroed out
      editPie(false)
    } else {
      return; }
    // Increasing or decreasing pie slices --- can be prettier
    // Get the percentage each pie slice against the remaining pie slices and inc/dec by that.
    function editPie(doInc){
      let incBy = doInc? inc:-inc
      // Variable deciding whether or not to modify all slices or just three
      let pieTestRange = changeAllSlices? pieData.length:3
      let decBy = incBy/(pieTestRange-1)
      let oVal = pieData[storyData.interact.pointLoc][accessors[1]]
      for (let i = 0; i <pieTestRange; i++){
        if (i == storyData.interact.pointLoc){pieData[i][accessors[1]]+=incBy} else {
          decBy = pieData[i][accessors[1]]/(100 - oVal)*incBy
          // decBy = pieData[i][accessors[1]]/(100 - pieData[0][accessors[1]])*incBy
          // This should be mutating storyData.interact.data
          pieData[i][accessors[1]]-=decBy
        }
      }
    }
    let p = storyData.interact.pointLoc
    // Save the pieSlice value
    // mod4[graphCounter].value = pieData[p][accessors[1]]
    if (!tutTime){mod4[graphCounter].inputData[0].userAnswer = pieData[p][accessors[1]]}

    // create function to draw the arcs of the pie slices.
    var arc = d3.svg.arc().outerRadius(chart.pieArea.r - 10).innerRadius(0);

    // create a function to compute the pie slice angles.
    var pie = d3.layout.pie(pieData).sort(null).value(function(d) { return d[accessors[1]]; });
    var pieInfo = pie(pieData)
    // console.log("newPi", pieInfo)


    let pointerCoor = [Math.cos((pieInfo[p].endAngle-pieInfo[p].startAngle)/2+pieInfo[p].startAngle-1.57)*(chart.pieArea.r+chart.arrowSize/4)*1+chart.bodyDim.w/2-chart.arrowSize/2
      , Math.sin((pieInfo[p].endAngle-pieInfo[p].startAngle)/2+pieInfo[p].startAngle-1.57)*(chart.pieArea.r+chart.arrowSize/4)*1+(chart.bodyDim.h/2-chart.arrowSize/2)]
    let pAngle = (pieInfo[p].endAngle-pieInfo[p].startAngle)/2 + pieInfo[p].startAngle
    // console.log(pAngle*180/Math.PI, pieInfo[1].startAngle*180/Math.PI, pieInfo[1].endAngle*180/Math.PI)
    chart.arrow
      .attr("transform", "rotate("+(pAngle*1*180/Math.PI+180).toString()+" "+(pointerCoor[0]+chart.arrowSize/2)+" "+(pointerCoor[1]+chart.arrowSize/2)+")")
      .attr("x", (d, i)=>{
        return pointerCoor[0]
      })
      .attr("y", (d, i)=>{return pointerCoor[1]})

    chart.pieArea.selectAll("path")
      .data(pie(pieData))
      .attr("d", arc)

    chart.highSlice
      .datum(pie(pieData)[p])
      .attr("d", arc)

    chart.plotArea.selectAll(".outline").selectAll("path")
      .data(pie(pieData))
      .attr("d", arc)

    // If icons
    // console.log("char", chart.plotArea.select(".icons").selectAll("image"), chart.plotArea.select(".outline").selectAll("path"))
    chart.plotArea.select(".icons")
      .selectAll("image")
      .attr("width", (d, i)=>{
        // if (i<3){
          // Check if the angle is greater than 180
          console.log("m", pieInfo[i].endAngle-pieInfo[i].startAngle, Math.PI*2, (pieInfo[i].endAngle-pieInfo[i].startAngle)/Math.PI*180)
          if (pieInfo[i].endAngle-pieInfo[i].startAngle<Math.PI){
            var xChange = Math.pow(Math.cos(pieInfo[i].endAngle)-Math.cos(pieInfo[i].startAngle),2)
            var yChange = Math.pow(Math.sin(pieInfo[i].endAngle)-Math.sin(pieInfo[i].startAngle),2)
            d.width = clampThings(Math.sqrt(xChange+yChange)*chart.pieArea.raySize*.8, chart.pieArea.imgCon.min, chart.pieArea.imgCon.max)
            d.raySize = chart.pieArea.r - d.width*.65 -10
          }
          // console.log("rd", d.width, d.raySize, chart.pieArea.r)
        // }
        return d.width
      })
      .attr("height", (d)=>{return d.width})
      .attr("x", (d, i)=>{
        // console.log("ray", chart.pieArea.raySize, Math.cos((pieInfo[i].endAngle-pieInfo[i].startAngle)/2+pieInfo[i].startAngle-1.57)*chart.pieArea.raySize, d.width)
        // return d.xPos = Math.cos((pieInfo[i].endAngle-pieInfo[i].startAngle)/2+pieInfo[i].startAngle-1.57)*chart.pieArea.raySize+chart.bodyDim.w/2-d.width/2
        return d.xPos = Math.cos((pieInfo[i].endAngle-pieInfo[i].startAngle)/2+pieInfo[i].startAngle-1.57)*d.raySize+chart.bodyDim.w/2-d.width/2
      })
      .attr("y", (d, i)=>{return d.yPos=Math.sin((pieInfo[i].endAngle-pieInfo[i].startAngle)/2+pieInfo[i].startAngle-1.57)*d.raySize+(chart.bodyDim.h/2-d.width/2)})

    // chart.testCirc
    //   .attr("cx", (d)=>{return d.xPos+d.width/2})
    //   .attr("cy", (d)=>{return d.yPos+d.width/2})
    //   .attr("r", (d)=>{return d.width/2})

  }

  function makeLine() {
    // Get the labels of the categories
    let labelArray = storyData.interact.data.map((d)=>{return d[storyData.interact.accessors[0]]})
    // Accesors for accessing the categories and values
    let accessors = storyData.interact.accessors
    let lineData = storyData.interact.data
    console.log('l', lineData)
    let tPoint = storyData.interact.pointLoc
    let pointLoc = typeof(storyData.interact.pointLoc)==='number'? clampThings(storyData.interact.pointLoc, 1, lineData.length-1) : (2<lineData.length-1? 2 : 1)
    storyData.interact.pointLoc = pointLoc

    chart = d3.select('#graphIImage').append("svg").attr("class", "lineGraph")
      .attr("preserveAspectRatio", "xMinYMax meet")

    chart.bodyDim = {w: bodyDim.w, h: bodyDim.h}
    chart.bodyDim.w = chart.bodyDim.w > chart.bodyDim.h ? chart.bodyDim.h*(storyData.interact.imageDim[0]/storyData.interact.imageDim[1]) : chart.bodyDim.w;
    chart.bodyDim.h = chart.bodyDim.w > chart.bodyDim.h ? chart.bodyDim.h : chart.bodyDim.w/(storyData.interact.imageDim[0]/storyData.interact.imageDim[1]);


    // might just need this going forward
    chart.bodyDim={w:storyData.interact.plotArea[0], h:storyData.interact.plotArea[1]}

    // Getting object array of points and weights to be manipulated
    // Might be a more automated way.
    // chart.manip = [{point: pointLoc==0?0:pointLoc, weight: pointLoc==0?1:(pointLoc==lineData.length-1?1:)}]
    // if (pointLoc == 0){
    //   chart.manip = [{point: pointLoc, weight: 1}, {point: pointLoc+1, weight: .6}, {point: pointLoc+2, weight: .3}]
    // } else if (pointLoc == lineData.length-1){
    //   chart.manip = [{point: pointLoc-2, weight: .3}, {point: pointLoc-1, weight: .6}, {point: pointLoc, weight: 1}]
    // } else {
    //   chart.manip = [{point: pointLoc-1, weight: .5}, {point: pointLoc, weight: 1}, {point: pointLoc+1, weight: .5}]
    // }

    chart.manip=[]
    let infPoints = lineData.length<3?1:((lineData.length)%2==1?Math.floor(lineData.length/2):lineData.length/2+1)
    console.log("infPoints", infPoints)
    let a=new Array(2)
    a[1]=(lineData.length-1)-tPoint
    a[0]=tPoint-0
    // console.log("a",a, tPoint)
    let test = a[0]<a[1]?0:1
    if (a[test]<Math.floor(infPoints/2)){
      a[test>0?0:1]=infPoints-1-a[test>0?1:0]
    } else {
      a=[Math.floor(infPoints/2),Math.floor(infPoints/2)]
    }
    for (let i=0; i<2; i++){
      for (let j=0;j<a[i];j++){
        if (i==0){
          chart.manip.push({point:tPoint-(a[0]-j), weight:Math.exp(-.5*(a[0]-j))})
        } else {
          chart.manip.push({point:tPoint+(1+j), weight:Math.exp(-.5*(1+j))})
        }
      }
      if (i==0){chart.manip.push({point:tPoint, weight:1})}
    }
    console.log("chart.m", chart.manip)
    // if (!isInteract){pointLoc=test>0?1:lineData.length-1}
    if (!isInteract){
      clampThings(pointLoc=test>0?tPoint-a[0]-1:tPoint+a[1]+1, 0, lineData.length-1)
    }

    // Adding the chart svg
    chart
      .attr("height", perc[1]*100+"%").attr("width", perc[0]*100+"%")
      .attr("viewBox", "0 0 "+chart.bodyDim.w.toString()+" "+chart.bodyDim.h.toString())
    // Setting the margin
    chart.margin = {top: chart.bodyDim.h*.01, right: chart.bodyDim.w*.01, bottom: chart.bodyDim.h*.01, left: chart.bodyDim.w*.01}
    // Adding buttons for changing the values
    for (let i =0; i<2; i++){
      let buttonType = i==0? "up" : "down"
      let isInc = i==0
      d3.select('#interactButtons').append("button")
        // .style("height", "20%")
        .attr("class", "button1 "+buttonType)
        .on("mousedown", ()=>{
          chart.highLine.style("opacity", "1")
          chart.lineDot.style("opacity", ".6")
          chart.inc=setInterval(function(){ incPoint(isInc) }, 50)
          // incPoint(isInc)
          clearTimeout(chart.timer);
          // chart.highLine.style("opacity", "1")
          // chart.lineDot.style("opacity", ".6")
          // chart.timer = setTimeout(()=>{
          //   chart.highLine.style("opacity", ".5")
          //   chart.lineDot.style("opacity", ".1")
          // }, 500)
        })
        .on('mouseout', ()=>{
          clearInterval(chart.inc)
          chart.timer=setTimeout(()=>{
            chart.highLine.style("opacity", ".5")
            chart.lineDot.style("opacity", ".1")
            if (lastGraph){mod4[graphCounter].timeQEnd=new Date().getTime()}
          }, 500)
        })
        .on('mouseup', ()=>{
          clearInterval(chart.inc)
          chart.timer=setTimeout(()=>{
            chart.highLine.style("opacity", ".5")
            chart.lineDot.style("opacity", ".1")
            if (lastGraph){mod4[graphCounter].timeQEnd=new Date().getTime()}
          }, 500)
        })

    }
    // Setting the plot area
    let chartRat = isInteract?.9:1.0
    chart.plotArea = chart.append("g").attr("class", "clip-chartArea")
    chart.plotArea.width = storyData.interact.plotArea[0]*chartRat
    chart.plotArea.height = storyData.interact.plotArea[1]*chartRat
    storyData.interact.imageDim[0]*=chartRat
    storyData.interact.imageDim[1]*=chartRat
    // chart.bodyDm

    // Setting the height and width of the chart based on the ratio of the image.
    // chart.plotArea.height = chart.bodyDim.h - chart.margin.top - chart.margin.bottom;
    // chart.plotArea.width = chart.bodyDim.w - chart.margin.left - chart.margin.right
    // // Need to redo this step because allocating room for the margin messes up the ratio of the chart body
    // chart.plotArea.width = chart.plotArea.height>chart.plotArea.width? chart.plotArea.width : chart.plotArea.height * storyData.interact.imageDim[0]/storyData.interact.imageDim[1]
    // chart.plotArea.height = chart.plotArea.height>chart.plotArea.width? chart.plotArea.width * storyData.interact.imageDim[1]/storyData.interact.imageDim[0] : chart.plotArea.height



    // clip the area
    chart.append("g")
      .append("clipPath")
      .attr("id", "clipperChartArea")
      .append("rect")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", chart.plotArea.width)
      .attr("height", chart.plotArea.height)


    // Setting the scales for the x and y coordinate system
    // chart.xScale = d3.scale.ordinal().domain(labelArray).range(d3.range(0, chart.plotArea.width, chart.plotArea.width/(labelArray.length)));
    labelArray.push("end")
    chart.xScale = d3.scale.ordinal().domain(labelArray).range(d3.range(labelArray.length).map((d)=>{
      if (d==labelArray.length-1){
        return chart.plotArea.width
      } else {
        return d / (labelArray.length-2) * (chart.plotArea.width-d / (labelArray.length-2)*storyData.interact.gridPadding[0]);
      }
    }));
    // chart.xScale = d3.scale.ordinal().domain(labelArray).range(d3.range(labelArray.length).map((d)=>{ return d / (labelArray.length-1) * chart.plotArea.width; }));
    // console.log("sc", chart.xScale.domain(), chart.xScale.range(), d3.range(labelArray.length).map((d)=>{ return d / labelArray.length * chart.plotArea.width; }))
    chart.yScale = d3.scale.linear().range([chart.plotArea.height, 0])
      // .domain([0, 1.1*d3.max(storyData.interact.data, function(d) { return d[storyData.interact.accessors[1]]; })])
      .domain([0, (storyData.interact.gridLines[1]+storyData.interact.gridPadding[1])*storyData.interact.yGridVal])
      .clamp(true)
    console.log("do", chart.yScale.domain())
    storyData.interact.stepSize = chart.yScale.domain()[1]*stepSize

    // define the line function
    chart.lineFunc = d3.svg.line()
      .x(function(d) { return chart.xScale(d[storyData.interact.accessors[0]]); })
      .y(function(d) { return chart.yScale(d[storyData.interact.accessors[1]]); });

    // Setting the calculated width and height to the chart plot area and moving accordingly
    chart.plotArea
        .attr("width", chart.plotArea.width)
        .attr("height", chart.plotArea.height)
        .attr("transform",
              "translate(" + 0 + "," + chart.bodyDim.h*(1-chartRat) + ")");

    // If there is an icon, setting it to a percent of the chart plot area
    // Needs to be fixed...
    // storyData.interact.iconDim = chart.plotArea.width/13
    chart.iconDim = chart.plotArea.width/13

    // Setting the start location to halfs
    if (isInteract){
      let downBy = lineData[pointLoc][accessors[1]]-chart.yScale.domain()[1]/2
      console.log("downBy", downBy, lineData[pointLoc], chart.manip)
      for (let i=0; i<=chart.manip.length-1;i++){
        lineData[chart.manip[i].point][accessors[1]]-=downBy*chart.manip[i].weight
      }
    }

    // This is the background image / the top
    chart.plotArea.append("image")
        .attr("class", "clip-svg2")
        // .attr("width", chart.plotArea.width)
        // .attr("height", chart.plotArea.height)
        .attr("width", storyData.interact.imageDim[0])
        .attr("height", storyData.interact.imageDim[1])
        .attr("xlink:href", storyData.interact.imagePath[1])

    // This is the foreground image / the bottom
    chart.plotArea.append("image")
      .attr("class", "clip-svg1")
      // .attr("width", chart.plotArea.width)
      // .attr("height", chart.plotArea.height)
      .attr("width", storyData.interact.imageDim[0])
      .attr("height", storyData.interact.imageDim[1])
      .attr("xlink:href", storyData.interact.imagePath[0])

      console.log('imgDDDDDD', storyData.interact.imageDim[0], storyData.interact.imageDim[1])

    // This is the line outline
    chart.plotArea.append("path")
      .datum(storyData.interact.data)
      .attr("class", "lineOutline")
      .attr("d", chart.lineFunc)
      .style("stroke", typeof storyData.interact.lineCol==="string"?storyData.interact.lineCol:"black")

    // Testing to see what happens if set the height or width to something specific...
    // chart.plotArea.append("image")
    //     // .attr("width", chart.plotArea.width)
    //     .attr("height", chart.plotArea.height)
    //     .attr("href", "./modules/graphQuestions/graphImages/rollerCoaster.png")

    // This is why pointLoc can't be = 0, clamps end but not beginning...
    chart.manipLines = storyData.interact.data.slice(tPoint-1, tPoint+2)
    // console.log("cM", chart.man)

    if (isInteract){
      chart.highLine = chart.plotArea.append("g").append("path")
        .datum(chart.manipLines)
        .attr("d", chart.lineFunc)
        .style("stroke", "#FF1493")
        .style("stroke-width", 3)
        .style("fill", "none")
        .style("opacity", .5)


      chart.lineDot = chart.plotArea.append("g").append("circle")
        .datum(chart.manipLines[1])
        .attr("cx", (d)=>{return chart.xScale(d[accessors[0]])})
        .attr("cy", (d)=>{return chart.yScale(d[accessors[1]])})
        .attr("r", 10)
        .attr("fill", "yellow")
        .style("opacity", 0.1)
    }
    // Add arrow....
    // chart.plotArea.append("g")
    if (isInteract){
      chart.append("g")
        // .datum(chart.manipLines[1])
        .attr("class", "arrowDown")
        .append("image")
        .attr("xlink:href", "modules/graphInteract/buttons/down.png")
        .attr("height", chart.bodyDim.h*(1-.005-chartRat))
        .attr("width", chart.bodyDim.h*(1-.005-chartRat))
        // .attr("width", chart.bodyDim.h*.095*102/149)
        // .attr("x", (d)=>{return chart.xScale(d[accessors[0]])})
        // .attr("y", (d)=>{return chart.yScale(d[accessors[1]])})
        // .attr("x", chart.xScale(storyData.interact.data[tPoint][accessors[0]])-chart.bodyDim.h*.095*102/149/2)
        .attr("x", chart.xScale(storyData.interact.data[tPoint][accessors[0]])-chart.bodyDim.h*(1-.005-chartRat)/2)
        // .attr("y", chart.yScale(storyData.interact.data[tPoint][accessors[1]])-40)
    }



    // NEED ICON DIM!!!
    // this is the icon attached to the line chart if used... a bit buggy but I suspect it has something to do with the rotation point.
    if (storyData.interact.withIcon){
      console.log("storyData.inte", storyData.interact)
      let iconD = {w: storyData.interact.iconDim[0], h:storyData.interact.iconDim[1]}
      let iconR = iconD.w/iconD.h
      console.log("iD", iconD.w, iconD.h)
      chart.iconD = {}
      chart.iconD.w = iconR < 1 ? chart.iconDim * iconR :chart.iconDim
      chart.iconD.h = iconR < 1 ? chart.iconDim : chart.iconDim * (1/iconR)
      console.log("iD", chart.iconD)
      if (isInteract){pointLoc = storyData.interact.iconLoc >= 1?storyData.interact.iconLoc:1}
      storyData.interact.iconLoc = pointLoc
      // >storyData.interact.imageDim[3][1]?chart.iconDim/storyData.interact.imageDim[3][1]*storyData.interact.imageDim[3][0]:storyData.interact.imageDim[3][0]
      let m = -(chart.yScale(lineData[pointLoc][accessors[1]])-chart.yScale(lineData[pointLoc-1][accessors[1]]))/(chart.xScale(lineData[pointLoc][accessors[0]])-chart.xScale(lineData[pointLoc-1][accessors[0]]))
      let xPos = (chart.xScale(lineData[pointLoc][accessors[0]])-chart.xScale(lineData[pointLoc-1][accessors[0]]))/2+chart.xScale(lineData[pointLoc-1][accessors[0]])-chart.iconD.w/2
      let yPos = (chart.yScale(lineData[pointLoc][accessors[1]])-chart.yScale(lineData[pointLoc-1][accessors[1]]))/2+chart.yScale(lineData[pointLoc-1][accessors[1]])-chart.iconD.h
      chart.plotArea.append("image")
          .attr("class", "icon")
          .attr("width", chart.iconD.w)
          .attr("height", chart.iconD.h)
          // .attr("position", "center")
          .attr("xlink:href", storyData.interact.imagePath[2])
          .attr("transform", "rotate("+(-Math.atan(m)*180/Math.PI)+","+(xPos+chart.iconD.w/2)+","+(yPos+chart.iconD.h)+")")
          // .attr("transform", "rotate("+(-Math.atan(m)*180/Math.PI)+","+(xPos)+","+(yPos)+")")
          .attr("x", xPos)
          .attr("y", yPos)
    }

    for (let i = 0; i <2; i++){
      let y0 = i==0? chart.yScale(0) : chart.yScale.range()[1]
      var area = d3.svg.area()
        .x(function(d, i) { return chart.xScale(d[accessors[0]]); })
        .y0(function(d) { return y0; })
        .y1(function(d) { return chart.yScale(d[accessors[1]]); });
      chart.plotArea
        .append("defs").append("clipPath")
        .attr("class", "c"+(i+1).toString())
        .attr("id", "clipper"+(i+1).toString())
        .append("path")
        .datum(lineData)
        .attr("class", "stackLine")
        .attr("d", area)
    }

    // Add gridlines
    // Need to add variable in information for these
    // let wLine = 2
    // let hLine = 3
    // let mLine = 2
    let wLine = storyData.interact.gridLines[0]
    let hLine = storyData.interact.gridLines[1]
    let mLine = storyData.interact.gridLines[2]
    console.log(storyData.interact.gridLines)
    // Get the data to filter out widths by 2
    let wData = lineData.filter((d,i)=>{ return i%wLine == 0 })
    // let wData = []
    // for (let i=0; i<wLine+1; i++){
    //   wData.push({col:storyData.interact.gridColor[0], xPos: chart.})
    // }
    // let hData = []
    // for (let i = 0; i < hLine+1; i++){
    //   hData.push({col: "black", yPos: chart.yScale.range()[0]/(hLine+1)*(i+1)})
    //   for (let j = 0; j < mLine; j++){
    //     hData.push({col: "grey", yPos: chart.yScale.range()[0]/(hLine+1)*(i)+chart.yScale.range()[0]/(hLine+1)/(mLine+1)*(j+1)})
    //   }
    // }
    // let hData = lineData.filter((d,i)=>{ return i%hLine == 0 })
    console.log(chart.yScale(storyData.interact.yGridVal))

    let hData = []
    for (let i = 0; i < hLine+1; i++){
      // hData.push({col: storyData.interact.gridColor[0], yPos: chart.yScale.range()[0]/(hLine+1)*(i+1)})
      hData.push({col: storyData.interact.gridColor[0], yPos: chart.plotArea.height-(i+1)*(chart.plotArea.height-chart.yScale(storyData.interact.yGridVal))})
      for (let j = 0; j < mLine; j++){
        // hData.push({col: storyData.interact.gridColor[1], yPos: chart.yScale.range()[0]/(hLine+1)*(i)+chart.yScale.range()[0]/(hLine+1)/(mLine+1)*(j+1)})
        hData.push({col: storyData.interact.gridColor[1], yPos: chart.plotArea.height-(i)*(chart.plotArea.height-chart.yScale(storyData.interact.yGridVal))+(chart.plotArea.height-chart.yScale(storyData.interact.yGridVal))/(mLine+1)*(j+1)})
      }
    }
    // let hData = new Array(hLine)
    chart.xGrid = chart.plotArea.append("g").attr("class", "xGrid")
      .selectAll("line")
      .data(wData)
      .enter().append("line")
      .attr("x1", (d)=>{return chart.xScale(d[accessors[0]])})
      .attr("x2", (d)=>{return chart.xScale(d[accessors[0]])})
      .attr("y1", (d)=>{return chart.yScale.range()[1]})
      .attr("y2", (d)=>{return chart.yScale.range()[0]})
      .style("stroke", storyData.interact.gridColor[0])

    chart.yGrid = chart.plotArea.append("g").attr("class", "yGrid")
      .selectAll("line")
      .data(hData)
      .enter().append("line")
      // .attr("x1", (d)=>{return chart.xScale.range()[0]})
      // .attr("x2", (d)=>{return chart.xScale(lineData[lineData.length-1][accessors[0]])})
      // .attr("y1", (d, i)=>{return chart.yScale.range()[0]/hData.length*i})
      // .attr("y2", (d, i)=>{return chart.yScale.range()[0]/hData.length*i})
      .attr("x1", (d)=>{return chart.xScale.range()[0]})
      .attr("x2", (d)=>{return chart.xScale(lineData[lineData.length-1][accessors[0]])})
      .attr("y1", (d, i)=>{return d.yPos})
      .attr("y2", (d, i)=>{return d.yPos})
      .style("stroke", (d)=>{return d.col})


    // Adding rectangular border
    chart.outline = chart.plotArea.append("g").attr("class", "lineOutline")
      .append("rect")
      .attr("x", chart.xScale.range()[0])
      .attr("y", chart.yScale.range()[1])
      // .attr("width", chart.plotArea.width)
      .attr("height", chart.plotArea.height)
      .attr("width", chart.xScale(lineData[lineData.length-1][accessors[0]])-chart.xScale(lineData[0][accessors[0]]))
      // .attr("height", chart.yScale(lineData[0][accessors[0]])-chart.yScale(lineData[lineData.length-1][accessors[0]]))
      .style("fill", "none")
      .style("stroke", "black")
      .style("stroke-width", 4)


    // saving value, will change if interacted withs
    if (mod4.length>0 && !tutTime)
      // mod4[graphCounter].value = lineData[pointLoc][accessors[1]]
      mod4[graphCounter].inputData.push({'userAnswer':lineData[pointLoc][accessors[1]]})
  }


  function incPoint (isInc){
    let lineData = storyData.interact.data
    let accessors = storyData.interact.accessors
    let inc = storyData.interact.stepSize
    let pointLoc = storyData.interact.pointLoc
    // if (isInc){
    //   lineData[pointLoc][accessors[1]]+=inc
    // } else {lineData[pointLoc][accessors[1]]-=inc}
    for (let i=0;i<=chart.manip.length-1; i++){
      // console.log("p", chart.manip[i].point)
      if (isInc){lineData[chart.manip[i].point][accessors[1]]+=inc*chart.manip[i].weight} else {
        lineData[chart.manip[i].point][accessors[1]]-=inc*chart.manip[i].weight}
    }

    // saving value
    // mod4[graphCounter].value = lineData[pointLoc][accessors[1]]
    if (!tutTime){mod4[graphCounter].inputData[0].userAnswer = lineData[pointLoc][accessors[1]]}

    for (let i = 0; i <2; i++){
      let y0 = i==0? chart.yScale(0) : chart.yScale.range()[1]
      var area = d3.svg.area()
        .x(function(d, i) { return chart.xScale(d[accessors[0]]); })
        .y0(function(d) { return y0; })
        .y1(function(d) { return chart.yScale(d[accessors[1]]); });
      chart.plotArea.selectAll(".c"+(i+1).toString()).select("path")
        .datum(lineData)
        .attr("d", area)
    }

    chart.highLine
      .attr("d", chart.lineFunc)

    chart.lineDot
      .attr("cx", (d)=>{return chart.xScale(d[accessors[0]])})
      .attr("cy", (d)=>{return chart.yScale(d[accessors[1]])})

    chart.plotArea.selectAll(".lineOutline")
      .datum(lineData)
      .attr("d", chart.lineFunc);

    if (storyData.interact.withIcon){
    pointLoc = storyData.interact.iconLoc
    let m = -(chart.yScale(lineData[pointLoc][accessors[1]])-chart.yScale(lineData[pointLoc-1][accessors[1]]))/(chart.xScale(lineData[pointLoc][accessors[0]])-chart.xScale(lineData[pointLoc-1][accessors[0]]))
    let xPos = (chart.xScale(lineData[pointLoc][accessors[0]])-chart.xScale(lineData[pointLoc-1][accessors[0]]))/2+chart.xScale(lineData[pointLoc-1][accessors[0]])-chart.iconD.w/2
    let yPos = (chart.yScale(lineData[pointLoc][accessors[1]])-chart.yScale(lineData[pointLoc-1][accessors[1]]))/2+chart.yScale(lineData[pointLoc-1][accessors[1]])-chart.iconD.h
      chart.plotArea.selectAll(".icon")
          .attr("transform", "rotate("+(-Math.atan(m)*180/Math.PI)+","+(xPos+chart.iconD.w/2)+","+(yPos+chart.iconD.h)+")")
          .attr("y", yPos)
          .attr("x", xPos)
      // let m = -(chart.yScale(lineData[pointLoc][accessors[1]])-chart.yScale(lineData[pointLoc-1][accessors[1]]))/(chart.xScale(lineData[pointLoc][accessors[0]])-chart.xScale(lineData[pointLoc-1][accessors[0]]))
      // let xPos = (chart.xScale(lineData[pointLoc][accessors[0]])-chart.xScale(lineData[pointLoc-1][accessors[0]]))/2+chart.xScale(lineData[pointLoc-1][accessors[0]])-storyData.interact.iconDim/2
      // let yPos = (chart.yScale(lineData[pointLoc][accessors[1]])-chart.yScale(lineData[pointLoc-1][accessors[1]]))/2+chart.yScale(lineData[pointLoc-1][accessors[1]])-storyData.interact.iconDim
      // chart.plotArea.selectAll(".icon")
      //     .attr("transform", "rotate("+(-Math.atan(m)*180/Math.PI)+","+(xPos+storyData.interact.icondDim/2)+","+(yPos)+")")
      //     .attr("y", yPos)
      //     .attr("x", xPos)
    }
  }

  // allow the participant to move on to the next
  function validate() {
    // console.log("validate")
      experimentr.endTimer('graphInteract');
      data.mod4=JSON.stringify(mod4)
      console.log(JSON.parse(data.mod4))
      experimentr.addData(data);
    // }
  }
}());
</script>
